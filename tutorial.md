# Python 基础教程

作者：@DarrenDanielDay

<Darren_Daniel_Day@hotmail.com>

## 写在前面

> 一个用Markdown写的`Python`的**语法和机制**教程。\
> 主要是用于解决一些初学者的疑惑。\
> 内容按照本人学习后总结的思路书写。\
> 如有错误或不准确的地方，欢迎指出并联系本人。

## 目录

我会按照这样的顺序来描述我对`Python`的理解。

1. [对象/Object][对象]
2. [函数/Function][函数]
3. [数据结构/Data Structure][数据结构]
4. [变量/Variable][变量]
5. [运算符/Operator][运算符]
6. [关键字/Key Word][关键字]
7. [库/Library][库]
8. [语法糖/Syntactic Sugar][语法糖]
9. [名词解释/Definations][名词解释]

## 对象

1. [什么是对象]
2. [为什么我需要知道对象的概念]
3. [Python的对象]
4. [面向对象的程序设计]
5. [object]

### 什么是对象

[对象]这个词是一个十分抽象的概念。\
简单来说，[对象]就是一个`“东西”`。\
比如说一个数字，一个公式，一条信息，一张图片，一张表，一首歌曲，一个程序……在计算机的世界里，他们存在的方式不过是杂乱无章的0与1的组合罢了。\
为了让他们有所区别，我们把他们隔离开来，不让这个0与1的组合与那个0与1的组合混起来，我们将每一个“个体”称为[对象]。

### 为什么我需要知道对象的概念

了解[对象]的概念，有助于你更好地理解[面向对象的程序设计]。\
面向对象的设计，可以让你的代码思路更加清晰。

### Python的对象

在`Python`中，**一切**都是[对象]。

> 请注意这里的**一切**不是指`代码`中的**一切**，而是在`程序`看来的一切。这一点和`JavaScript`是类似的。\
`Python`的所有[对象]都是[object]的[实例]，所有的[类]都是[对象]，所有的[类]都是[object]的[子类]。

### 面向对象的程序设计

面向对象有三大特性：

1. [封装]
2. [继承]
3. [多态]

#### 封装

我认为[封装]这个概念很好地解释了什么叫[对象]。\
[封装]也可以称为`数据抽象`。\
封装的主要思想是：隐藏[对象]的[数据]和[方法]的实现细节，对外仅提供一些[接口]进行访问。\
这话看起来有些抽象。打个比方：
> 假设你买了一个台式电脑主机。主机里面有很多零件，包括一些存储设备，它们就好比是[数据]。主机也可以完成一些事情，比如读取磁盘，这些就好比是主机的[方法]。但是，你买来的主机一般都是装在一个外壳里面的。如果不把外壳拆开，你就只能通过主机上可以插入显示器的[接口]、可以插入USB的[接口]等来与主机进行交互。事实上，作为使用者的你也并不需要去关心这些[数据]是怎么存储的，也不关心读取磁盘的[方法]的细节，是什么硬件完成的。你只需要通过可用的[接口]来访问他们就可以了，例如在显示屏的[接口]插上一个显示屏来显示内部存储的[数据]（实际上还需要安装操作系统、文件系统等），或者在USB[接口]插上U盘来传输[数据]，等等。这里，你买的主机就是一个[对象]。它是一个整体，它的硬件（[数据]）和功能（[方法]）被[封装]在一个大箱子里。其他提到的如显示器、U盘，也是[对象]，它们也有自己的硬件和功能，也被装在一个外壳里。

#### 继承

[继承]也可以称为`泛化`。\
如果一个[类]B[继承]了一个[类]A，那么我们说[类]A是[类]B的[父类]，并且B是A的[子类]。\
[继承]具有传递性。即：如果A[继承]了B，B[继承]了C，那么A也[继承]了C。A是B的[子类]，同时也是C的[子类]。
[子类]拥有[父类]的全部[数据]和[方法]，并且可以在此基础上进行扩展。
> 尽管[继承]的机制比较简单，但我们还是需要知道如何设计[父类]与[子类]。\
> 假设有[类]`动物`，它[封装]了[数据]`“叫声”`以及[方法]`“叫”`。`狗`是一种[类]，`猫`也是一种[类]，他们都是一种`动物`，因此应该有`“叫声”`的[数据]和`“叫”`的[方法]。如果用[继承]的机制，我们就不必再去为`猫`和`狗`去重复指定它们有`叫声`以及会`叫`。

#### 多态

[子类]的[实例]也是[父类]的[实例]。\
一个[子类]的[实例]的[方法]的具体实现可以和其[父类]的[实例]有所不同，是一种[多态]的表现。\
换言之，[子类]可以[重写] [父类]的[方法]，是[多态]的一种表现。

> 如上面的例子，`猫`和`狗`都有`叫声`，并且会`叫`，但是`叫声`不同。`狗`的`叫声`是“汪汪汪”，`猫`的`叫声`是“喵喵喵”。并且，`狗``叫`的时候还会伴随着头部的抖动，而`猫`不会。因此，虽然[类]`狗`和[类]`猫`都[继承]了[类]`动物`，但我们希望他们在`“叫”`这个[方法]上有不同的表现。因此我们可以通过[重写]它们[父类]的[方法]`“叫”`来解决这个问题。

同一个[接口]可以由不同的[对象]实现，也是一种[多态]。
> 例如前面的USB[接口]。能在USB[接口]进行[数据]交换的不只是U盘，还有鼠标、键盘、移动硬盘、光驱等，只要是有（实现了）USB[接口]的设备，都可以通过USB[接口]接入主机进行[数据]交换。

### object

在`Python`中，[object]是所有[类]的[父类]。\
所有[类]在不说明[继承]什么[类]的时候都默认[继承] [object]。

## 函数

1. [什么是函数]
2. [参数]
3. [函数体]
4. [函数调用]
5. [返回]
6. [Python-函数]
7. [Python-自定义函数]
8. [Python-参数传递]

### 什么是函数

在高中我们学过，数学中的`函数`是数集到数集的映射。\
但是在编程语言中不是这个意思，尽管他们有些相似的地方。\
一个[函数]接收一些[参数]，做一些事情，[返回]一些结果。\
[函数]可以看成是一个大程序中的子程序。

一般地，一个[函数]由函数名称及[参数列表]、函数实现（[函数体]）以及一些注解构成。

### 参数

[参数]，英文Parameter，是一个[函数]可能需要的，指明一些信息的[对象]。在[函数体]中，[参数]往往用[变量]来表示。
就像数学里的函数需要一个具体的自变量的值才能计算函数值一样，编程语言中的[函数]也需要一些[参数]才能运作。
和数学不同的是，编程语言中的[函数]的[参数]不一定是数，而且[参数]的个数也不一定是一个，可以是多个。至于具体是什么[类型]的[参数]，需要多少个[参数]，不同的[函数]会有所不同，也有的[函数]不接收[参数]（接收0个[参数]）。

### 函数体

[函数体]是[函数]的主要部分，在[函数体]内包含了[函数]做的事情，以及[返回]的信息。

在`Python`的代码中，[函数体]是与函数声明连续并且多一个[缩进]的[代码块]。

### 函数调用

这里有一个`Python`初学者非常容易犯的错误：写了一个[函数]的定义却没有[函数调用]的代码，然后运行代码看不到任何运行结果。
本文中的[函数调用]，英文Call，指的是给一个[函数]传入适当的[参数]，让它工作起来。
有关`Python`的[函数调用]机制，详见[运算符\(\)]。

### 返回

[返回]，英文Return，是[函数]在正常执行完毕后，向调用者提供运行的结果的行为，尽管[函数]运行的所有结果不一定都通过[返回值]来体现。
一些编程语言如`C/C++`、`Java`的[函数]也可以不[返回]任何值，即[返回]一个无法使用的`void`[类型]的值。在这种情况下，[返回]就只是让[函数]执行结束罢了。
而`Python`的[函数]一定有[返回值]，即使你不去显式地去执行[返回语句]。

1. [返回值]
2. [返回语句]

#### 返回值

[返回值]是[函数]正常执行完后向调用者提供的运行结果。
在`Python`中，[返回值]是一个[对象]。

#### 返回语句

在[函数]中，用于说明执行到这里就应该结束[函数调用]，向调用者提供执行结果的语句。
在`Python`中，[返回语句]应当使用[关键字] [return]。
当一个[函数]被调用后，执行到了[返回语句]，那么[函数]就会向调用者[返回]结果，并结束[函数]的执行，回到调用函数的地方。

### Python-函数

`Python`中的[函数]也是[对象]，尽管这对于`C/C++`、`Java`这样的语言来说并不成立。\
一个`Python`[函数]，根据其定义的[参数列表]，接收相应个数的[参数]，可能是0个[参数]（没有[参数]），也可能是任意固定个数的[参数]，也可能是个数可变的[参数]。
之后，[函数]会利用这些[参数]（也可以不用）做一些事情，比如做一些运算，存储一些信息，创建一些窗口等等。只要是代码能实现的事情，[函数]都可能会做。
最后，[函数]会[返回]一个[对象]，作为[函数]的[返回值]。

### Python-自定义函数

`Python`中自定义函数需要使用[关键字] [`def`][def]。

一个`Python`[函数]的定义大致是这样的格式：

```python
def function_name(parameter_list):  # 这里是函数的声明，包括了函数的名称以及参数列表。
    ......                          # 这里是函数体。
    return return_value             # 这里是函数体，并且这一行是一个返回语句。
```

你可以在代码中的任何行自定义一个[函数]，尽管这样做很可能会带来不必要的麻烦。

一般地，`Python`的[函数体]是连续的位于声明下方的具有比函数声明多一个[缩进]的[代码块]。

其中的[返回语句]：

```python
    return return_value
```

可以没有。如果这样做，当[函数调用]并执行到[函数体]的最后时，函数将会[返回] [`None`][None]。

当然，你也可以为[函数]添加一些注解（官方翻译：标注），使得你的编写思路更加清晰。虽然`Python`解释器会去处理这些注解，但这不太会影响[函数]的执行。

```python
def function_name(parameter1:int,parameter2:str,paramater3:list)->dict:
    ......
    return return_value
```

另外，你还可以为[函数]添加[装饰器]。具体参见[装饰器]。

### Python-参数传递

1. [参数列表]
2. [参数传递]

#### 参数列表

1. [位置参数]
2. [含默认值的位置参数]
3. [可变参数]
4. [仅键值参数]
5. [字典参数]
6. [参数列表语法]

[参数列表]是[函数]需要的[参数]的清单，是在[函数]的定义处定义的。\
`Python`[函数]的[参数]将在[函数体]内作为[局部变量]使用。
各个[参数]都必须有自己的名字，命名规则参考[变量名]。[参数列表]中各个参数用逗号`,`隔开。\
[参数列表]的合理顺序是：[位置参数]，[含默认值的位置参数]，[可变参数]，[仅键值参数]，[字典参数]。

##### 位置参数

直接为[参数]取名即可。可以有0个或任意有限个，个数必须是确定的。

例如：

```python
def func1():
    pass

def func2(a):
    pass

def func3(a,bcd,e,fff,ggggg):
    pass
```

##### 含默认值的位置参数

为[参数]取名后，在名称右边附上等号`=`并在等号右边指定其默认值。[参数列表]中可以有0个或任意有限个，个数必须是确定的。[函数调用]时如果没有接收到，那么将会使用默认值。

> 值得注意的是：默认值只会初始化一次。也就是说，如果使用了默认值，那么它总是指向同一个[对象]。如果这个[对象]是可变的，那么当这个[对象]被改变了，使用的默认值也会受到影响。

例如:

```python
def func4(a=1,b=""):
    pass
```

##### 可变参数

为[参数]取名后，在名称左边附上星号`*`。

这个[变量名]用于接收“多余”的通过[位置传递]获得的[参数]。它将多余的[参数]集中在一起，构成[元组]，并指向这个[元组]。

**一个[函数]的[可变参数]只能有0个或1个。**

**不建议将[含默认值的位置参数]和[可变参数]同时使用，因为这样做在[函数]被调用的时候，要么默认值失去意义，要么[可变参数]失去意义，尽管这不会在语法上产生问题。**

##### 仅键值参数

[仅键值参数]在[参数列表]中的写法和[位置参数]一致，但是[仅键值参数]必须在[可变参数]的后面。
简单思考一下就会明白其中的道理：[可变参数]用于接收多余的[位置传递]的[参数]，那么在[可变参数]之后的[参数]自然不可能通过[位置传递]获得值。要想让他们获得值，只能通过[键值传递]或[键值解包]来传递。

[仅键值参数]允许有默认值，写法同[含默认值的位置参数]。

> 值得注意的是，[仅键值参数]必须靠[键值传递]，因此不像[位置参数]那样，并没有“不带默认值的要在带默认值的前面”这一限制。当你看了[参数传递]以后，你会理解这一点。

##### 字典参数

为[参数]取名后，在名称左边附上两个星号`**`。这个[变量名]将会与传入的无法[赋值]给[位置参数]的[键值传递]传入的[参数]构成的[字典]所绑定。\

##### 参数列表语法

以上的几种[参数]都可以混合使用，但是要注意遵循一些语法。

本人已知的[参数列表]语法包括以下：

1. [参数列表]的顺序应当是这样：[位置参数]，[含默认值的位置参数]，[可变参数]，[仅键值参数]，[字典参数]
2. 一个[参数列表]中的[可变参数]和[字典参数]只能有0个或1个，其余无数量限制。
3. 五类[参数]使用的[变量名]都不可以重复。

```python
def f1(p1,p2=1,*args,k1,k2=1,k3,**kwargs):
    pass                # 正确

def f2(p1,p2=1,k1):
    pass                # 语法错误，k1是位置参数，顺序不符合

def f3():
    pass                # 正确

def f4(*a1,*a2):
    pass                # 语法错误，不符合2

def f5(p1,*p1):
    pass                # 语法错误，不符合3
```

#### 参数传递

1. [位置传递]
2. [键值传递]
3. [解包传递]
    * [迭代解包]
    * [键值解包]
4. [传递机制]

合理的[参数传递]顺序是：[位置传递]，一个星号`*`的[解包传递]，[键值传递]，两个星号`**`的[解包传递]。
前文所说的[参数列表]中使用[含默认值的位置参数]和[可变参数]同时使用的歧义就会在这里会产生。

##### 位置传递

通过逗号`,`将被传递的[对象]隔开，按照顺序[赋值]给[参数列表]中的[变量]。如果[位置参数]的个数不对，将会引发[异常]。

##### 键值传递

通过`[名称]=[值]`的方式传递。

如果[位置参数]（包括带默认值的）能够匹配到相同的`[名称]`，那么这个`[值]`将会被[赋值]给那个[参数]。

如果接收[参数]的[函数]的[参数列表]无法处理该名称将会引发[异常]。

##### 解包传递

###### 迭代解包

通过在[表达式]前面加一个星号`*`将[可迭代对象]进行[迭代]，并将各次[迭代]的[返回值]用逗号分隔后`替换`接收的位置传入。

###### 键值解包

通过在[对象]前面加两个星号`**`将[字典]的[键值对]解释成`[key]=[value]`的形式传入，就像[键值传递]一样。

##### 传递机制

本人已知的语法检查机制包括以下：

1. 检查[键值传递]是否存在重复的[键]。如有，则引发[异常]。
2. 检查[键值传递]的[键]是否为合法的名称，即不可用[表达式]作为[键]。如不合法，则引发[异常]。
3. 检查是否有[键值传递]的[参数]在[位置传递]的[参数]前面。如有，则引发[异常]。
4. 检查所有[迭代解包]是否都在所有的[键值解包]的前面，如果不是，则引发[异常]。

如果以上语法没有问题，大概再按这样的方式来进行传递。

1. 先将[迭代解包]的[对象]进行[迭代]，得到[序列]，将[序列]插入被[迭代解包]的位置，作为[位置参数]使用。如果这个[函数]是一个[类]的[实例]的成员，那么将会把这个[实例]添加到[序列]的首部（一般是传给self[参数]）。最终，可以得到一个总的[参数]的[序列]。
2. 然后开始进行[`位置传递`][位置传递]。将这个总的[序列]按其顺序将[参数]取出，并从左到右[赋值]给[参数列表]中的[位置参数]（包括[含默认值的位置参数]）。如果[赋值]完成后，还有[参数]剩余，则会尝试将多余[参数]的打包成一个[元组]，并将这个元组[赋值]给[可变参数]，若[参数列表]中没有[可变参数]，则引发[异常]。没有[参数]多余但[参数列表]中有[可变参数]的情况，[可变参数]会被[赋值]为空的[元组]。
3. 将带[键值解包]的[对象]进行mapping，得到一些[键值对]，将这些[键值对]作为[键值传递]使用。如果有任何[键]不是[字符串]的[实例]，则引发[异常]。如果有任何[键值解包]得到的[键]与[键值传递]的[键]发生重复，则引发[异常]。
4. 接下来开始`键值传递`。不断取出一个[键值对]，将[键]对应的值[赋值]给名称与[键]相等的[位置参数]、[含默认值的位置参数]、[仅键值参数]。如果这些[参数]已经被[赋值]，则引发[异常]。如果[赋值]完以后，还有多的[键值对]没有使用，则尝试将其打包成一个[字典]，并将这个[字典] [赋值]给[字典参数]，若[参数列表]中没有[字典参数]，则引发[异常]。没有[键值对]多余但[参数列表]中有[字典参数]的情况，[字典参数]会被[赋值]为空的[字典]。
5. 如果经过以上步骤以后[含默认值的位置参数]和给出了默认值的[仅键值参数]没有被[赋值]，那么他们将会被其默认值[赋值]。
6. 如果经过以上步骤以后，还有[参数]没有被[赋值]的[参数]，则引发[异常]。

## 数据结构

1. [类型]
2. [布尔类型]
3. [数]
4. [字符串]
5. [列表]
6. [元组]
7. [集合]
8. [字典]

### 类型

说起[类型]，就还是得再提一提这件事：

> 计算机的世界其实是0和1的组合，至少现在还是这样。

那么，0与1的组合为何能够表示出不同的含义呢？我们需要的就是[类型]。使得这些0与1的组合能够有所区别的，是[类型]的作用。
更简单的理解是：[类型]就是说明[对象]属于哪个[类]。当然，这个理解不适用于没有[类]机制的编程语言。

> 举一个简单的例子。学过C语言的人应该知道这样的一件事：'0'==48。为什么呢？因为[字符]'0'占一个字节的存储空间，所对应的二进制码是0x30，也就是十进制的48。因此，同样的二进制码0x30，你可以把它解释成[字符]'0'，也可以解释成数字48。单从二进制码上来讲，'0'和48是相等的，而[类型]则规定了我们应该如何来解释这些二进制码。

当然，`python`的[类型]机制比这个例子要复杂的多，在这里就不（wo）深（bu）入（hui）了。

### 布尔类型

[布尔类型]也是[不可变对象]，是[可哈希对象]。
[布尔类型]是最简单的[类型]。它只有两种可能的值：[`True`][True]或者[`False`][False]。
[`True`][True]代表真，[`False`][False]代表假。
[布尔类型]是逻辑的基础。
[`True`][True]和[`False`][False]都是[关键字]。

### 数

这里的[数]指的是`Python`中用于计算的数[对象]。
`python`中的[数]都是[不可变对象]，是[可哈希对象]。

1. [整数]
2. [浮点数]
3. [复数]

#### 整数

在这里，[整数]的概念和数学中的`整数`是一致的。

英文：Integer

`Python`中的[类]名：int

1. [数制]
2. [计算机中的整数表示]
3. [整数常量]

##### 数制

以下是一些与十进制、二进制等进制有关的数学知识，并且可能颠覆你对`数`的认识。如果你理解数制的概念，可以[跳过](#整数常量)。

数制是用于表示数值的方法。一个数制由基数和位权组成。
数字是数值在数制下的文字表现。不管是用哪种数制表示数字，只要其数值相等，我们就可以在这些数字之间划上等号。
数字是表象的，数值才是本质的。
数值是十分抽象的。为了说明这一点，请看下面的例子。

现在，下面的区域有一些`&`：

> &&&&&&&&&

请问有多少个`&`？

有小学一年级以上的数学水平的人都能够很快地回答出：

> 这里有`9`个`&`。

但是当你继续看下去，会发现问题没有这么简单。

为什么是`9`个？不是`$`个也不是`%`个，而是`9`个，或者是`九`个。看到`$`和`%`你可能会看不懂我在说什么，这很正常，因为这两个符号是我随便挑的。

实际上，问题的本质是：`9`只是一个符号，而我们人为地赋予它**与前面那块区域中`&`的个数**相同的意义。

**但是，`9`只是一个符号而已，至于为什么这样写，那要问造出这个符号的人**。

而`9`，正是一个十进制数字。它只是一种数值在十进制下的表现形式。

然后我借助大家熟知的十进制来解释一下数制的机制。

> 一个数制中有一个基数和以及一些个数与基数相等的数码。一个该数制下的数字由这些数码组成（小数点是可选的）。

对于十进制，其基数应当和正常人手指的个数相等，对应的数码分别是`0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`，`8`，`9`。

> 每个数码都对应了一些确定的数值。

十进制的这些数码对应的值的多少应当在小学一年级就有学过，此处略。

> 一个数制还有位权。位权是指一个数码在数字中的一个位置上的权。有关权的概念请自行查阅资料。\
> 一般地，对于在A进制（A>1）下的数字，位权可以这样确定：\
> 如果没有小数点，最右边的位置上权为1。如果有小数点，小数点左边的位置上权为1。\
> 每向左一位，权变为A倍。每向右一位，权变成1/A。

对于十进制[整数]，从右向左的权依次是1，10，100，1000……

> 数字代表的数值是数字中所有数码乘以其位权的总和。

例如十进制数字`12344`，按照前面的规则，权依次是10000，1000，100，10，1。因此，这个数字代表的数值就和这个[表达式]的值相等：\
`1*10000+2*1000+3*100+4*10+4*1`

尽管我这里使用了`10000`、`4`等十进制数字来代表数值，但这不影响含义的表达。

如果你完全理解了这些，那么你大概已经知道二进制是什么了。
二进制的基数是2，对应的数码是`0`，`1`。
二进制[整数]的权值从右往左依次是1，2，4，8，16，32……
二进制[整数]`1011`表示的数值就是用十进制数字写的[表达式]`1*8+0*4+1*2+1*1`的值，即十进制数字`11`的值。

然后计算机科学中常用的八进制和十六进制我就可以这样简单带过了。
八进制的基数为8，数码是`0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`。位权的规则和前文介绍的一致。
十六进制的基数为16，数码是`0`，`1`，`2`，`3`，`4`，`5`，`6`，`7`，`8`，`9`，`A`，`B`，`C`，`D`，`E`，`F`，其中`A`，`B`，`C`，`D`，`E`，`F`对应的值是十进制的10~15。字母也可以用小写的。位权的规则和前文介绍的一致。

尽管我花了大量篇幅来解释数制，但我不想在这里介绍不同进制的数字之间如何转换，因为这是纯粹的数学知识，并且`Python`也提供了相应的库支持，而介绍数制只是为了补充概念。

> 请注意：转换前后的两个数字是**相等**的，它只是换了一种表示形式，因为进制转换不会改变数值。

##### 计算机中的整数表示

在计算机科学中，[整数]一般都是以二进制补码存储的。

以经典的32位[整数]为例，总共有32个二进制位供存储值，每个二进制位都只可能是0或者1。我们姑且将这32个二进制位从左到右排列，越往左边，权值越高，这和数学里面的习惯是一样的。最高位是符号位，是特殊的位，可以用于表示符号，0表示正数，1表示负数。

每个二进制位的权值从右到左依次是1（2的0次方），2（2的1次方），4（2的2次方），8（2的3次方）……，1073741824（2的30次方），-2147483648（**负**2的31次方）。与众不同的只有最高的符号位，其权值是负值。

一个[整数]的32位二进制补码的手算方法：

1. 根据符号判断符号位是什么。
2. 将这个[整数]的绝对值用31位的二进制表示，不足的高位用0填充（如果超过31位，则这个数无法用32位二进制补码表示）
3. 如果是正数，则直接到6。
4. 如果是负数，那么将这31位全部变成相反，0的地方变成1，1的地方变成0，最后加上1（二进制加法，满二进一）。
5. 如果4的加法在第31位产生了进位，那么这个数无法用32位二进制补码表示（溢出）。
6. 结合符号位和31位得到结果。

例如，十进制的78对应的32位二进制补码是：
`00000000000000000000000001001110`

十进制的-78对应的32位二进制补码：
先把31位取反，得到
`1111111111111111111111110110001`
然后加1得到
`1111111111111111111111110110010`
最后添上符号位得到
`11111111111111111111111110110010`

同样我们可以得到十进制的-1对应的32位二进制补码是（非常特别，所有位都是1）：
`11111111111111111111111111111111`

##### 整数常量

[整数常量]的几种表示方法如下：

```python

# 十进制整数，由十进制数码和下划线"_"构成，不以"_"和"0"开头，不以"_"结尾，且"_"不可连续出现。

18640       # 18640
18_640      # 18640
18640_      # 语法错误
018640      # 语法错误
13__13      # 语法错误
_18640      # 语法上不错误，但这并不是代表整数常量18640。

# 二进制整数，以0b或者0B开头，后面的部分由"0"，"1"，"_"构成，不以"_"结尾，且"_"不可连续出现。

0b11111     # 31
0B1010      # 10
0b001_1     # 3
0b_111010   # 58
0b100_      # 语法错误
0b12        # 语法错误


# 八进制整数，以0o或者0O开头，后面的部分同二进制，但是多了数码2~7。

0o3417      # 1807
0O12471     # 5433

# 十六进制整数，以0x或者0X开头，后面的部分同二进制，但是多了数码2~9以及a~f和A~F。

0xa_78afD_F # 175681503

```

> 下划线是比较特别的存在，它可以用来使得数字常量更易读，正如一些较大的十进制数字每三位用逗号隔开一样。\
> 值得注意的是，负号是一个运算符，它并不在[整数常量]的表示当中。

#### 浮点数

顾名思义，[浮点数]就是小数点的位置可以浮动的小数，其本质也是数值的表示方式。
英文：Floating Point

`Python`里的[类]名：float

1. [浮点数常量]

##### 浮点数常量

在`Python`中，[浮点数常量]不像[整数]那样有那么多进制可以用，只有十进制。

[浮点数常量]有两种表示方式：浮点表示和指数表示（即科学计数法）

1. [浮点表示]
2. [指数表示]

###### 浮点表示

```python
# 由整数部分、小数点以及小数部分组成。
# 整数部分以及小数部分和十进制整数类似，但是都可以以0开头。
# 整数部分是可选的，若无则视作0。
# 小数部分也是可选的，若无则视作0。需要注意的是：这样做得到的不是整数而是浮点数，尽管他们在值上相等。
# 整数部分和小数部分不可同时省略。
# 以下都是合法的浮点表示。

3.14
0123.1
1.
0_1.1_2_3
123.
0123.
.1
.0

```

###### 指数表示

```python
# 指数表示由浮点数部分和指数部分构成。
# 浮点数部分和浮点数表示基本一致，但是也可以没有小数点。
# 指数部分由"E"或者"e"开头，接下来可选添加指数的符号"+"和"-"，最后是可以以0开头的十进制整数。
# 以下都是合法的指数表示。

3.14e0
314e-2
1.29e+03
.9e-1_0
9_8.e-01

```

#### 复数

[复数]是什么，是纯粹的数学知识，在此不做介绍。

在这里主要介绍`Python`中虚部的表示。

在`Python`中，虚数单位用`j`表示。将其附加在十进制[整数]或者[浮点数]的后面表示这个数乘上虚数单位。使用十进制[整数]时，可以以0开头。

```python
# 以下都是合法的虚数。

3.14j
10.j
010j
.001j
1e100j
3.14e-10j
3.14_15_9j

```

### 字符串

[字符串]是[字符]的[序列]。它可以用于存储文字信息。
`Python`中的[字符串]是[不可变对象]。

1. [字符]
2. [字符串常量]
3. [一些常用的字符串操作]
4. [正则表达式]

#### 字符

我们已经知道计算机的世界是0与1的组合。存储在计算机世界的[数据]也一样，是0与1的[序列]。而[字符]就好比是文本[数据]的0与1的[序列]中有意义的最小子[序列]。一个英文字母`I`，一个数字`9`，一个特殊符号`⑨`，一个汉字`九`等等都是[字符]。

一个[字符]根据其内容和编码格式，对应的0与1的[序列]会有所不同。不同的[字符]所占的字节数也不同，有的一个字节，有的两个字节，还有的占更多。关于编码格式，请自行查阅相关资料。

与`C/C++`、`Java`等语言不同，`Python`的内置[数据结构]中没有“[字符]”这个[类型]，而是用只有单个[字符]的[字符串]来代替。

#### 字符串常量

[字符串]的内容被一对双引号`"`或者一对单引号`'`括起来，也可被一对`"""`或者`'''`括起来。两者的区别在于后者内部可以包含换行符。
[字符串]的内容被解释成什么[字符]，由引号前面的[字符串前缀]决定。[字符串前缀]不区分大小写。

1. [字符串前缀]
2. [转义字符]

##### 字符串前缀

`Python`目前（3.7.4版本）有三种[字符串前缀]：

* r ：表示不对[转义字符]进行转义
* f ：表示利用`python`[表达式]来进行[格式化]。
* u ：表示统一码。

用法及更多细节见官方文档：<https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#string-and-bytes-literals>

##### 转义字符

顾名思义，`转义`就是改变原来的意思。

不仅仅是`Python`中有，其他大多数的语言中也存在。

[转义字符]通常是由反斜杠`\`与其他[字符]组成的，其中反斜杠的作用就是改变其后面的[字符]的含义。

常用的[转义字符]：

|[转义字符]|含义|
|-|-|
|`\\`|[字符]`\`|
|`\'`|[字符]`'`|
|`\"`|[字符]`"`|
|`\n`|换行符|
|`\t`|水平制表符|
|`\[ooo]`|以三位八进制[整数]`[ooo]`为编码的[字符]|
|`\x[xx]`|以两位十六进制[整数]`[xx]`为编码的[字符]|

用法及更多细节见官方文档：<https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#string-and-bytes-literals>

#### 一些常用的字符串操作

1. [拼接]
2. [复制]
3. [格式化]
4. [索引与切片]
5. [查找与替换]
6. [正则表达式]

##### 拼接

[字符串常量]的[拼接]可以直接接续在前面一个的后面，但是换行接续需要用括号以消歧义。例如：

```python
'one''two'          # 等价于'onetwo'

"three"'four'       # 等价于'threefour'

(
    "ab"            # 你可以在这些地方添加注释
    "cd"            # 并且这不会对这个字符串造成影响
    'ef'
)                   # 等价于'abcdef'

```

准确地来说，这并不是[拼接]，而是[字符串常量]的表示方法，尽管这看上去好像是把多个[字符串]拼在了一起。

[拼接]也可以用[字符串]的加法（[运算符+]）。但是每次做加法都会创建新的[字符串]，因此，如果需要大量[拼接]但不需要中间结果的[字符串]，建议使用`str.join(s:str,iterable:Iterable)`[方法]。

##### 复制

如果需要得到一个[字符串]的若干次[复制]后并[拼接]起来的[字符串]，可以使用[字符串]的乘法（[运算符*]）。

```python

"复读"*3            # 得到"复读复读复读"

3*"复读"            # 也可得到"复读复读复读"

```

##### 格式化

如果需要将某些[数据]填入一个具有固定格式的[字符串]的适当位置，则用直接拆开并[拼接]的方式是很不合理的，并且那样的格式也不易于阅读。[字符串]的[格式化]很好地解决了这个问题。

[字符串]的[格式化]一般有两种方法，一种是通过[字符串]的[运算符%]（是一个历史遗留问题，不推荐），另一种是通过`str.format(s:str,\*args,\*\*kw)`[方法]（推荐）。

如果你学过C语言，那么你应该可以很快掌握[运算符%]的使用方法，它的风格和C语言的printf[函数]很像。详见官方文档：<https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting>

##### 索引与切片

[字符串]的[实例]是[可迭代对象]，是可用[索引]访问的，它就好像由一些单个[字符]的[字符串]构成的[列表]（但[字符串]不是[列表]的[实例]），也是可以[切片]的。
有关[索引]的语法，详见[列表]。
有关[切片]，详见[语法糖]。

[字符串]的[迭代]就像C语言里面遍历char数组的每个char那样。[字符串]每次[迭代] [返回]的是当前[迭代]位置的单个[字符]组成的[字符串]。

##### 查找与替换

###### 子串查找

判断[字符串]src是否包含子[字符串]target可以用[运算符in]：

```python
target in src
```

查找某个子串的[索引]有两种[方法]：

1. `str.index(src:str, sub:str, start:int=0, end:int=-1)->int`
2. `str.find(src:str, sub:str, start:int=0, end:int=-1)->int`

两者都[返回]在src中从start[索引]开始，end[索引]结尾的子串中sub[字符串]第一次出现的[索引]。
对于1，若不存在子串将会引发[异常]。对于2，若不存在[返回]-1。

###### 子串替换

使用[方法]：`str.replace(s:str, old:str, new:str)->str`。

##### 正则表达式

[正则表达式]可以判断一个[字符串]是否符合某种格式，并获取格式中相应的信息。例如一个我们知道电子邮件地址的格式，对于一个具体的邮箱地址我们想知道它的邮箱服务器域名。如果要用[索引与切片]、[子串查找]之类方法来判断和提取信息，会变得很麻烦。而[正则表达式]则能够高效完成这个任务。

[正则表达式]的详细使用方法请参考`python`[标准库]的[re模块](https://docs.python.org/zh-cn/3/library/re.html)资料，在这里只做简单介绍。

1. [正则式]
2. [编译对象]
3. [match对象]

###### 正则式

[正则式]（其实就是[正则表达式]，只为与另一标题区分）是正则匹配中最核心的。

一些元字符在[正则式]中具有特殊含义。

元字符|匹配规则
-|-
`.`|匹配除换行符以外的任意单个[字符]
`*`|匹配位于`*`之前的模式0次或更多次
`+`|匹配位于`+`之前的模式1次或更多次
`|`|匹配位于`|`之前或之后的模式
`^`|匹配行首，匹配以`^`后面的[字符]开头的[字符串]
`$`|匹配行尾，匹配以`$`之前的[字符]结束的[字符串]
`?`|匹配位于`?`之前的模式0次或1次
`\`|表示位于`\`之后的为[转义字符]
`[]`|匹配位于`[]`中的任意一个[字符]
`-`|用在`[]`之内用来表示范围
`()`|将位于`()`内的内容作为一个整体来对待，并存入groups
`{}`|按`{}`中的次数进行匹配

---

此外，还有一些[转义字符]。

[转义字符]|含义
-|-
`\b`|匹配单词头或单词尾
`\B`|与`\b`含义相反
`\d`|匹配任何数字，相当于`[0-9]`
`\D`|与`\d`含义相反
`\s`|匹配任何空白[字符]
`\S`|与`\s`含义相反
`\w`|匹配任何字母以及下划线，相当于[a-zA-Z0-9_]
`\W`|与`\w`意义相反

其余普通的[字符]均匹配自身。

如果你下载了本教程附的代码，你可以直接运行[它](./samplecode/regex.py)以查看结果，并加深自己的理解。
举个例子，一个可行的匹配电子邮件的[正则式]是：

```python
rex=r"(\w+)@(\w+(\.\w+)+)"
```

简单解释一下：

* `\w+`用于匹配至少一个[字符]的单词。
* 这里认为用户名全部由字母、下划线、数字组成的（即`\w`的含义），且至少一位（即`+`的含义）
* `@`匹配自身。
* `(\.\w+)+`用于匹配若干个`.com`、`.net`等域名成分，域名至少有一个`.xxx`。
* `(\w+(\.\w+)+)`匹配的是域名整体。

###### 编译对象

有了[正则式]以后，我们还需要将其做成一个re.compile[对象]。这个[对象]可以重复使用，用来匹配符合[正则式]的[字符串]，得到相应的[match对象]。

```python
# rex借用上文的正则式
import re
compile_object=re.compile(rex)  # 这样就得到了编译对象compile_object
```

###### match对象

有了[编译对象]以后，我们就可以开始让它去匹配要匹配的[字符串]。匹配成功则[返回]一个[match对象]，否则[返回] [`None`][None]。

```python
# compile_object使用的是上文的
target1="someone@example.com"
target2="someone@notcorrect"
match_object1=compile_object.match(target1) # 匹配成功
match_object2=compile_object.match(target2) # 匹配失败，match_object2是None
```

我们可以根据`re.Match.group`[方法]得到匹配出的分组的信息。
第1和第2组是我们想要的用户名和邮箱服务器域名。

```python
name=match_object1.group(1)
host=match_object2.group(2)
print(f"用户名：{name}")
print(f"主机域名：{host}")
```

### 列表

英文：List

在`python`中的[类]名：list

[列表]是一个方便的容器。它能够将一些[对象]全部装在一起。

[列表]有点像数组。[列表]和数组不同的是：里面存放的[对象]的[类型]不一定要一样。

> **需要注意的一点是：[列表]中存放的是[对象]的[引用]，不是[对象]的拷贝！**

`Python`中的[列表]是[可变对象]，是[不可哈希对象]。

1. [创建列表]
2. [列表索引]

#### 创建列表

可以直接用中括号`[]`将以逗号隔开的需要放入[列表]的[对象]（或[表达式]）[序列]括起来，得到一个[列表]的[实例]。你也可以通过[迭代解包]来得到这些[序列]。空的[列表]可以用`[]`来表示。

例如：

```python
list1=[1,"a",False]
```

可以得到一个[列表]list1。

也可以用[类]list(iterable:Iterable)进行构造。传入一个[可迭代对象]即可，[返回]一个以[可迭代对象]的[迭代] [序列]生成的[列表] [实例]。
例如：

```python
list2=list(range(5))
```

就可以得到一个内容为`[0,1,2,3,4]`的[列表]list2。

此外，还有[推导式]可以生成[列表]，以及一些[函数]可能会[返回]一些[列表]。

#### 列表索引

[列表]既然能把[对象]装进去，自然能够将[对象]取出来。这需要[索引]。
[索引]就好像目录里的页码，知道了在第几页就能把要的找出来。

[列表索引]是一个[整数]，它代表[列表]中某个元素的位置。
[列表索引]也是如此，但是要注意的是：**程序员数数总是从0开始**。

也就是说，[列表]首元素的[索引]是0。
用[索引]访问[列表]的某个元素，可以用[运算符\[\]]。

和其他大多数语言不同的是：`Python`有负的[索引]。负的[索引]是从最后开始数的，[列表]中最后一个[对象]的[索引]是-1，每向前一个[索引]减一。

例如，使用刚刚的代码中的list1，以下[索引]访问将得到以下结果：

```python
list1[0]            # 得到1
list1[1]            # 得到"a"
list1[-1]           # 得到False
```

此外，[列表索引]得到的可以作为[左值]进行[赋值]。

```python
list1[0]='change'   # 此时list1变成了['change','a',False]
```

有关[列表]的其他资料，请参考官方文档：<https://docs.python.org/zh-cn/3/library/stdtypes.html?highlight=list#lists>

### 元组

英文：Tuple

在`python`中的[类]名：tuple

简单地说，[元组]就是不可更改每个[索引]对应的[对象]的[引用]，也不可以增加或减少[对象]的[引用]的[列表]。

创造[元组]的方法和[列表]差不多，但用的是圆括号`()`和tuple(iterable:Iterable)。

[元组]是[不可变对象]，但这个“不可变”仅限对[对象]的[引用]不变，并不是说[元组]内的[对象]都是[不可变对象]。
因此，[元组]是[可哈希对象]。

> [元组]比[列表]少了改变[引用]的能力，那为什么不都用[列表]？\
这是因为不可改变[引用]意味着更加安全可靠。如果我们不需要去修改一个表的内容，那就把它做成不可变的就可以了。\
**能用[元组]不用[列表]的时候尽量使用[元组]。**

### 集合

英文：Set

在`python`中的[类]名：set

[集合]这种[数据结构]和数学意义上的集合一样，具有确定性、无序性、唯一性，但是只能存放[可哈希对象]，并且[哈希值][哈希]与判断[集合]内两个元素是否相等密切相关。

1. [创建集合]

#### 创建集合

[创建集合]和[创建列表]的方式差不多，只不过不用方括号`[]`而是花括号`{}`。`set(iterable:Iterable)`也是好的。由于[集合]具有唯一性，故[序列]中的重复元素将会被自动筛去。

### 字典

英文：Dictionary

在`python`中的[类]名：dict

[字典]在其他语言中也叫Map（映射），其作用就是将一个[可哈希对象]（作为键）与一个任意的[对象]（作为值）建立映射关系（即[键值对]）。一个[字典]包含的是若干[键值对]。同一个[字典]的[键]是不可能重复的，一个[键]只能对应一个值。

就像查字典一样，给字典一个单词，字典就能够告诉你这个单词的解释。当然，如果字典里没有这个单词，就找不到了。

1. [创建字典]
2. [字典索引]

#### 创建字典

类似于[列表]，[字典]也可以用类似的方法构建。将[键值对]用逗号分开，并用花括号`{}`括起来即可得到一个[字典]。可以使用[键值解包]来添加[键值对] [序列]。

[键值对]的写法：`键:值`

可以通过`{}`来创建一个空的[字典]。

#### 字典索引

[字典索引]的语法类似于[列表索引]，但是`[]`中不一定是[整数]，可以是任何[可哈希对象]。如果直接用[运算符\[\]]进行访问且作为右值，则当[键]不存在的时候将会引发[异常]。作为[左值]的情况，当[键]不存在将会创建相应的[键]。

比较保守的做法是使用\
`dict.get(self:dict, key:object, default:object=None)->object`\
这样当[键]不存在时会[返回]default[参数]，并且default[参数]的默认值是[`None`][None]。从代码量上来说，用[运算符\[\]]更加省事，但是用get更加安全。

## 变量

[变量]是用于指向[对象]、使用[对象]的一个媒介。有关“指向”的含义，参考[赋值]。

1. [变量名]
2. [赋值]
3. [作用域]

### 变量名

[变量名]是[变量]的名字。在绝大多数时候，我们用[变量名]来指代[变量]本身，或者是指代[变量]所指向的[对象]。

1. [变量命名]

#### 变量命名

`python`的[变量命名]规则如下：

1. 可用英文字母、数字、下划线（也可以用中文字符等，但不提倡），区分大小写。
2. 不可和关键字一致。
3. 不以数字开头，中间不可被空白字符（如空格、换行符、制表符）隔开。
4. 可以和内置函数名一样，但这将会覆盖内置函数的行为，不提倡。

### 赋值

[赋值]是将一个[对象]的[引用]与一个[变量]绑定。

> 需要注意的是：`python`中的[赋值]是[引用]的绑定，不会进行拷贝，也就是一个指向。

[赋值]的语法主要有两种：

1. [直接赋值]
2. [解包赋值]
3. [引用]

#### 直接赋值

`[左值]`=`[右值]`即可
[左值]可以是[变量名]，也可以是可以被[赋值]的[引用]（如[列表]和[字典]的[索引]访问到的）。
只要是符合命名规则的[变量名]，都是可以被[赋值]的。如果原先这个[变量名]不存在，那么这个[变量]会被创建。如果存在，那么它的指向就会改变。
[右值]可以是任意的[对象]。

```python
a=1
cdd='户山香澄'
shopping_list=['鸡蛋','西红柿','白糖','菜油']
today={'status':'good','weather':'sunny'}

```

#### 解包赋值

[解包赋值]可以算是一个`python`的[语法糖]。

基本的是这样的：

`[左值1],[左值2],...[左值n]=[右值1],[右值2],...[右值n]`

这样将会将右边的[右值] [序列]依次[赋值]给左边的[左值] [序列]。

例如：

```python
a,b=0,1
```

差不多和这效果一致：

```python
a=0
b=1
```

而右边也可以只有一个[对象]。如果这样做，当左边有多个[对象]需要被[赋值]时，效果相当于

```python
a,b,c=[1,2,3]
a,b,c=*[1,2,3]
```

有关`*`的[迭代解包]，参考[函数]的[参数传递]部分。

#### 引用

有时候也叫做“指向”。这个概念比较抽象，如果需要直接解释可能需要很多C语言的知识，本人在此用一个形象的例子来解释。

假设有一个人A，父母给他取名为“王小明”（如有姓名雷同，纯属巧合）。那么，父母会用“王小明”这个名字来指代他，这就好比“王小明”这个名字指向了他这个人。王小明在公司上班，同事们都叫他“小王”。“小王”这个名字自然是从“王小明”来的。用`python`代码来讲这就是：

```python
王小明="某个人A"
小王=王小明
```

假设后来公司里来了个新人B，也姓王，父母给她取名叫“王小红”（如有姓名雷同，纯属巧合）。由于年龄还是“王小明”大，于是同事们用“小王”称呼“王小红”，而改用“老王”称呼“王小明”。这用`python`代码来讲就是：

```python
王小红="某个人B"
小王=王小红
老王=王小明         # 你可以忽略这一句，因为这一句和本例要表达的逻辑关系不大。
```

显然根据现实中的逻辑，现在“小王”指代（指向）的应该是"某个人B"，并且“王小明”指代（指向）的应该是"某个人A"。

那么，你现在应该也可以理解这段代码（初学者极易犯的错误）是为什么了：

```python
a=1
b=a
b=2
print(a)            # 在控制台输出a的值，结果是1
```

此外，你也应该能够理解这里的[函数]f为什么无法改变外部[变量]的值：

```python
def f(n):
    n=100

a=1
f(a)
print(a)            # 在控制台输出a的值，结果是1

```

### 作用域

[作用域]是一个[变量名]能够被正常解析的范围。

一般来说，一个[变量]的[作用域]是从它被定义开始，到同一级结构的结尾处结束。

但是`Python`[变量]的[作用域]有所不同。`python`是解释型语言，因此，[变量名]的解析与定向不像C语言那样在编译时就可以通过代码结构确定。`python`的[变量名]解析是通过[字典]来完成的。你可以通过内置函数来获取信息。

内置函数globals()->dict[返回]调用时所有[全局变量]的[变量名]到[对象]的映射[字典]。
内置函数locals()->dict[返回]**调用处**的局部[变量名]到[对象]的映射[字典]。

1. [命名空间]
2. [局部变量]
3. [全局变量]
4. [成员变量]

#### 命名空间

[命名空间]是一个用于存储名称的空间。它主要用来对名称进行管理，以避免重复名称之间的冲突。

在`Python`中，一般来说，[命名空间]可以由[模块]和[类]来产生。

#### 局部变量

局部[变量]一般是指在[函数]内部定义的[变量]。它不属于任何[命名空间]，只是一个临时的[变量]，只有属于同一个局部的代码能对它进行正常解析，[变量名]超出了这个局部就不再指向这个局部所指向的[对象]。

`Python`中[局部变量]的[作用域]通常是[函数]调用时的整个栈帧。

#### 全局变量

[全局变量]是相对于局部[变量]来说的。[全局变量]指向的[对象]应当可以在任何地方被任何[对象]所[引用]。

在`python`中，如果需要在局部使用[全局变量]指向的[对象]，可以直接将[全局变量]的[变量名]作为[右值]使用，但是要注意：局部变量的名称解析优先于[全局变量]。如果想在一个[函数]的局部改变[全局变量]的[引用]（将[变量名]作为[左值]进行[赋值]），则需要使用关键字global，但是本人不建议这样做。随意修改[全局变量]是很危险的，可能会导致与该[变量]相联系的部分受到很大的影响。

当一个脚本被作为[模块]导入时，脚本中的[全局变量]将属于该[模块]的[命名空间]。
当一个脚本被当作主模块执行时，里面的[全局变量]属于__main__[模块]。

#### 成员变量

[成员变量]就像是[对象]的[数据]和[方法]一样的存在的[变量]。他们的访问方式是通过成员访问运算符（[运算符\.]）。

当在一个[类] [命名空间]中创建[变量]时，这个[变量]将会成为[类]的[成员变量]。

当一个[模块]被以`import xxx`的方式导入后，[模块]中的[全局变量]将会成为[模块]的成员。

## 运算符

运算符是一些特殊的符号，我们可以用它来完成一些对[对象]的操作。运算符和[对象]构成了运算的[表达式]。

运算符需要有操作的[对象]才能工作起来。这些[对象]就是运算符的**操作数**。

有些运算符只需要一个操作数，叫做单目运算符。
有些运算符需要两个操作数，叫做双目运算符。

`python`中的运算符本质其实也是[函数调用]，即`python`支持[运算符重载]。内置类型的这些[函数]已经被实现，并且无法修改。

官方文档定义的运算符包括以下：

```text
+       -       *       **      /       //      %      @
<<      >>      &       |       ^       ~
<       >       <=      >=      ==      !=
```

而在本文的解释中，运算符还包括这些：

```text
()      []      .
=       +=      -=      *=      /=      //=     %=
@=      &=      |=      ^=      >>=     <<=     **=
```

虽然运算符很多，但是我们还是可以大致这样分开讨论：

1. [运算符重载]
2. [算术运算符]
3. [逻辑运算符]
4. [比较运算符]
5. [位运算符]
6. [赋值运算符]
7. [其他运算符]

### 运算符重载

[运算符重载]是重新定义运算符的作用。其本质其实是定义一些特殊的[函数]。

[运算符重载]可以使得代码更加简洁，同时也可能会使代码变得生涩难懂，例如为自定义[类]`Student`（包含一个学生信息的封装[类]）重载[运算符+]就显得莫名其妙。但是有些[类]的[运算符重载]就很符合逻辑，例如[第三方库]numpy中的`numpy.matrix`（矩阵[类]）就重载了[运算符+]。这样，矩阵的加法可以通过[运算符+]来进行，而不需要去记忆一些名称复杂的[库]函数来完成，并且这样写也可以让一些逻辑更加像数学中的写法。机制允许你对任何自定义的[类]进行[运算符重载]，但是需不需要这样做，以及这样做好不好，就难说了。

### 算术运算符

算术运算符一般用于对数的运算操作。

1. [运算符+]
2. [运算符-]
3. [运算符*]
4. [运算符**]
5. [运算符/]
6. [运算符//]
7. [运算符%]
8. [运算符@]

#### 加号

[运算符+]可以作为单目运算符和双目运算符。

作为单目运算符，是取正。

与取正运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__pos__(self)`|+ self

self指代操作数自身。

以下是一些内置类型的取正的含义：

操作数|[返回值]
-|-
[数]|数学意义上的正号，相当于乘以正一

作为双目运算符，是加法。

与加法运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__add__(self, other)`|self + other
`__radd__(self, other)`|other + self

其中字母`r`的含义大概就是`right`（右边）。

它们都是[对象]的[方法]。other指代另一个操作数。

尽管加法应当满足交换律，但是你很快会知道，交换律不一定成立，例如[字符串]的加法。

当一个[类]重载了[函数]`__add__`后，这个[类]的[实例]就可以作为[运算符+]的左操作数。
当一个[类]重载了[函数]`__radd__`后，这个[类]的[实例]就可以作为[运算符+]的右操作数。

在重载的[函数]的[函数体]中，应当对另一个操作数other的[类型]做类型检查。如果认为接收到的[类型]不支持，应当[返回]NotImplemented。

[运算符+]会先尝试调用左操作数的`__add__`[方法]，如果[返回]了NotImplemented或者未定义，就再尝试右操作数的`__radd__`。如果两者都[返回]了NotImplemented或未定义，那么将引发[异常]。

> 如果右操作数[类型]为左操作数[类型]的一个[子类]，且该[子类]提供了指定运算的反射[方法]（以r开头的，如`__radd__(self, other)`），则此[方法]会先于左操作数的非反射[方法]被调用。此行为可允许[子类]重载其祖先[类]的运算符。这对于所有具有反射[方法]的运算符都适用。

其他的需要两个操作数的运算符（双目运算符）机制与上述类似，后文将不再赘述。

以下是一些内置类型加法的含义：

左操作数|右操作数|[返回值]
-|-|-
[数]|[数]|数学意义的加法结果
[字符串]|[字符串]|拼接后的[字符串]
[列表]|[列表]|拼接后的[列表]
[元组]|[元组]|拼接后的[元组]

一个重载的[例子](./samplecode/operators.py)：

```python
from functools import wraps

def show(func):
    @wraps(func)
    def shower(*args,**kw):
        print(func.__name__)
        return func(*args,**kw)
    return shower

class LR:
    def __init__(self,x):
        self.x=x

    @show
    def __pos__(self):
        return self

    @show
    def __add__(self,other):
        if isinstance(other,LR):
            return self.x+other.x
        return self.x+other

    @show
    def __radd__(self,other):
        if isinstance(other,LR):
            return self.x+other.x
        return self.x+other

l=LR(2)
r=LR(3)

print(l+1)
print(1+r)
print(l+r)
print(+r)
```

#### 减号

[运算符-]可以作为单目运算符和双目运算符。

作为单目运算符，是取负。

与取负运算有关的[函数]如下：

函数原型|对应运算
-|-
`__neg__(self)`|- self

以下是一些内置类型的取负的含义：

操作数|[返回值]
-|-
[数]|数学意义上的负号，相当于乘以负一

作为双目运算符，是减法。

与减法运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__sub__(self, other)`|self - other
`__rsub__(self, other)`|other - self

以下是一些内置类型减法的含义：

左操作数|右操作数|[返回值]
-|-|-
[数]|[数]|数学意义的减法结果
[集合]|[集合]|两者的差集

#### 星号

[运算符*]可以作为单目运算符和双目运算符。

准确来说，作为单目运算符，是解包的[表达式]，[返回]的是一个[序列]（并不是一个[对象]）。详情请参考[解包传递]相关内容。

作为双目运算符，是乘法。

与乘法运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__mul__(self, other)`|self * other
`__rmul__(self, other)`|other * self

以下是一些内置类型乘法的含义：

左操作数|右操作数|[返回值]
-|-|-
[数]|[数]|数学意义的乘法结果
[列表]|[整数]|[列表]复制[整数]倍后的[列表]，若为0或负[整数]，[返回]空[列表]
[整数]|[列表]|[列表]复制[整数]倍后的[列表]，若为0或负[整数]，[返回]空[列表]
[元组]|[整数]|类似于[列表]
[整数]|[元组]|类似于[列表]
[字符串]|[整数]|类似于[列表]
[整数]|[字符串]|类似于[列表]

#### 双星号

[运算符**]可以作为单目运算符和双目运算符。

准确来说，作为单目运算符，是解包的[表达式]，对[对象]使用mapping协议。详情请参考[解包传递]相关内容。

作为双目运算符，是求幂。它与内置函数pow(base, index[, modulo])有一定的关系。

与乘法运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__pow__(self, other[, modulo])`|self ** other（当传入第三个[参数]时，对应内置函数pow）
`__rpow__(self, other)`|other ** self

重载了这两个[函数]之一的类也会使得内置函数pow接收到该[类型]的[参数]时产生关联。

以下是一些[数]求幂的结果：

左操作数|右操作数|[返回值]
-|-|-
[整数]|[整数]|[整数]的幂（精确，不存在误差）
非负实数|实数|实数幂（存在舍入误差）
负实数|非[整数]|利用欧拉公式等求得的幂，辐角取主值（存在舍入误差）
[数]|[复数]|利用欧拉公式等求得的幂，辐角取主值（存在舍入误差）
[复数]|[数]|利用欧拉公式等求得的幂，辐角取主值（存在舍入误差）

#### 除号

[运算符/]是双目运算符，对于[数]，其含义是复数集内的除法。

与除法运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__truediv__(self, other)`|self / other
`__rtruediv__(self, other)`|other / self

当两个操作数都是[数]且右操作数为0时，将会引发[异常]。

#### 双斜杠

[运算符//]是双目运算符。对于[数]，其含义是地板除法，得到的是对实数除法的结果用高斯函数取整的值，但是当有操作数是[浮点数]时，[返回]的总是[浮点数]。

例如：

```python
1//2            # 得到0
7//3            # 得到2
(-7)//3         # 得到-3
3.8//1.3        # 得到2.0
```

与地板除法运算符有关的[函数]如下：

函数原型|对应运算
-|-
`__floordiv__(self, other)`|self // other
`__rfloordiv__(self, other)`|other // self

当两个操作数都是[数]且右操作数为0时，将会引发[异常]。

在[数]的地板除法中，右操作数不可以是[复数]。

#### 百分号

[运算符%]是双目运算符。

对于[数]，其含义是取模。如果`a`和`b`都是实数，则`a`%`b`得到的大致等于`a-((a//b)*b)`

例如：

```python
1%2             # 得到1
7%3             # 得到1
(-7)%3          # 得到2
3.8%1.3         # 得到1.1999999999999997（存在一定的舍入误差）
```

对于[字符串]作为左操作数的情况，将会用右操作数对左边的[字符串]进行[格式化]，[返回] [格式化]后的[字符串]。[格式化]的风格和C语言的printf很像。

但是这样的[字符串][格式化]并不是很好，甚至官方文档里面也有吐槽：

> 注解： 此处介绍的[格式化]操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示[元组]和[字典]）。 使用较新的 [格式化] [字符串]字面值，str.format() [接口]或 模板[字符串] 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。

详细[格式化]的方法请参考官方文档：<https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting>

与运算符%有关的[函数]如下：

函数原型|对应运算
-|-
`__mod__(self, other)`|self % other
`__rmod__(self, other)`|other % self

当两个操作数都是[数]且右操作数为0时，将会引发[异常]。

在[数]的取模运算中，右操作数不可以是[复数]。

当左操作数是[字符串]且占位符个数与获得的填充元素个数不一致时，将会引发[异常]。

#### 艾特

本人已知的符号@在`python`中有两个作用，而大部分人只知道它和[装饰器]有关。

这个不为人知的作用就是矩阵乘法运算符。（这还是谷歌了英文内容才找到的，~~**_装逼神器_**~~）

有关[装饰器]，将在[语法糖]部分介绍。

与运算符@有关的[函数]如下：

函数原型|对应运算
-|-
`__matmul__(self, other)`|self @ other
`__rmatmul__(self, other)`|other @ self

`python`第三方数学[库]numpy中就有矩阵[类]，重载了这个运算符。**如果你没有安装numpy[模块]，以下的代码将无法正常运行**。

```python
import numpy

m1=[[1,0,0],[0,2,0],[0,0,3]]
m2=[[2,0,0],[0,2,0],[0,0,2]]

mat1=numpy.asmatrix(m1)
mat2=numpy.asmatrix(m2)

print(mat1)
print(mat2)
print(mat1@mat2)

```

### 逻辑运算符

逻辑运算符用于逻辑的“运算”。逻辑的运算总是围绕着[布尔类型]的。

关于逻辑，你需要知道三种基本逻辑。

假设有两个[布尔类型]的[对象]`a`和`b`，则

* `a`或`b`：为False当且仅当`a`和`b`都为False
* `a`与`b`：为True当且仅当`a`和`b`都为True
* 非`a`：为True当且仅当`a`为False。

简单来说，可以化成下面的真值表：

`a`|`b`|`a`或`b`|`a`与`b`|非`a`
-|-|-|-|-
[`True`][True]|[`True`][True]|[`True`][True]|[`True`][True]|[`False`][False]
[`True`][True]|[`False`][False]|[`True`][True]|[`False`][False]|[`False`][False]
[`False`][False]|[`True`][True]|[`True`][True]|[`False`][False]|[`True`][True]
[`False`][False]|[`False`][False]|[`False`][False]|[`False`][False]|[`True`][True]

在`python`中，逻辑运算符或、与、非都是以关键字的形式存在的，分别是[`or`][or]、[`and`][and]、[`not`][not]，但大多数语言都是以符号形式存在的，例如C语言的或与非分别是`||`、`&&`、`!`。在本文中，我们姑且将这三个关键字视作运算符。

有趣的是，在`python`中传给这些逻辑运算符的[对象]不一定要是[布尔类型]的，这一点和Javascript很像。那么如何判断非[布尔类型]的[实例]的逻辑呢？答案是通过内置函数`bool(x:object)`。

如果希望非[布尔类型]的[对象]能够拥有逻辑值，可以通过[重写] [函数]：`__bool__(self)->bool`来实现。在默认情况下，一个自定义[类]的[实例]的布尔值总是True。

下面是一些内置类型的特殊量的布尔值：

[对象]|布尔值
-|-
空[列表]|[`False`][False]
空[元组]|[`False`][False]
空[字典]|[`False`][False]
空[字符串]|[`False`][False]
[整数]0|[`False`][False]
[浮点数]0.0|[`False`][False]
[复数]0j|[`False`][False]
非空[字符串]，如'0'|[`True`][True]
非空[列表]，如[0]|[`True`][True]

简单而言，空的或者为0的内置类型的[实例]布尔值都是False，不为空的内置类型[实例]布尔值为True。

1. [运算符not]
2. [运算符and]
3. [运算符or]
4. [逻辑短路]

#### 运算符not

[运算符not]将会[返回]与操作数布尔值相反的布尔值，并且一定[返回]布尔值。

#### 运算符and

[运算符and]将会[返回]第一个布尔值为False的[对象]。如果两者的布尔值都是True，那么[返回]后一个[对象]。

例如：

```python
a=[] and True
b=True and ""
c=[] and {}
d=1 and "abc"
print(a,b,c,d)      # 结果：[]  [] abc
                    # b是空字符串，所以看不到
```

#### 运算符or

[运算符or]将会[返回]第一个布尔值为True的[对象]。如果两者的布尔值都是False，那么[返回]后一个[对象]。

例如：

```python
a=[] or True
b=True or ""
c=[] or {}
d=1 or "abc"
print(a,b,c,d)      # True True {} 1
```

#### 逻辑短路

如果你理解了运算符相当于[函数体]，而[函数]在[返回]后就会结束执行，那么应该可以很快理解什么是[逻辑短路]。

如果[运算符and]运算符的第一个操作数布尔值为False，那么第二个操作数会被短路，如果是[表达式]，则不会被计算。
如果or运算符的第一个操作数布尔值为True，那么第二个操作数会被短路，如果是[表达式]，则不会被计算。

虽然逻辑运算的优先级比较低，但是当局部可以决定整体的逻辑时，逻辑运算的过程会马上结束，不去管无法改变最终逻辑结果的部分，即使那部分可能会带来一些别的工作。这就好比NBA总决赛7局4胜，打到4：2就不打第7局一样。这不是计算机在偷懒，也不是什么奇葩的机制，相反，机智的程序员会很好地利用这一点。

下面的代码可以加深你的理解。

```python

def t():
    print('调用函数t()')
    return True

def f():
    print('调用函数f()')
    return False

def test(n):
    print(f"第{n}次测试")

test(1)
a=f() and t()
test(2)
b=f() and f()
test(3)
c=t() and t()
test(4)
d=t() and f()
print(a,b,c,d)

test(5)
a=f() or t()
test(6)
b=f() or f()
test(7)
c=t() or t()
test(8)
d=t() or f()
print(a,b,c,d)
```

### 比较运算符

[比较运算符]主要是用于比较大小，因此他们都是双目运算符。它们应当[返回]一个布尔值。

比较两个不同[类型]的[对象]的大小，不是很推荐，除非他们所属的[类]有着一定的[继承]关系。

`python`官方文档没有将这些归为运算符，而是归为`分隔符`。

[比较运算符]包括以下：

1. [运算符<]
2. [运算符>]
3. [运算符<=]
4. [运算符>=]
5. [运算符==]
6. [运算符!=]

#### 小于号

即[运算符<]。

对应的可[重写] [函数]为
`__lt__(self, other)`

`lt`大概是less than的缩写。

一般来说，若[运算符<]的左操作数比右操作数小，将[返回]True，否则[返回]False。

对于实数，其大小就是数学意义上的大小。
对于[字符串]，其大小就是字典序大小。
对于[列表]和[元组]，其大小比较的规则类似于字典序，将按照顺序对包含的[对象]进行比较。
[字典]不可以比较大小，但是可以比较是否相等，两个[字典]相等当且仅当所有的[键值对]相等。
[集合]可以比较大小，但是比较逻辑比较奇怪，不建议使用。当一个[集合]是另一个[集合]的真子集的时候，真子集更小。当两个[集合]的元素完全相同时两个[集合]相等。其他情况都是既不大于也不小于也不相等，但是不会引发[异常]。

对于自定义的[类]，默认是不支持比较的，需要显式地[重写] [函数]`__lt__(self, other)`以使用[运算符<]进行比较。

一般来说，我们最好保证[运算符<]有`传递性`：即如果`a < b`成立并且`b < c`成立，那么应该有`a < c`成立。

> 需要注意的是，重载了[运算符<]后就不必再重载[运算符>]，除非有这样的必要，因为大于的逻辑和小于应当是对称的，要判断`a > b`是否成立只需要判断`b < a`是否成立就可以了。

如果[类]A[重写]了`__lt__(self, other)`[函数]，那么对于[类]A的[实例]`a1`和`a2`，当需要对[表达式]`a1 > a2`进行求值的时候，会尝试调用`A.__lt__(a2, a1)`。类似的，如果重载了[运算符>]的[类]B[实例]`b1`和`b2`需要对[表达式]`b1 < b2`求值时也会尝试调用`B.__gt__(b2, b1)`一样。

由重载了[运算符<]的自定义[类]的[实例]构成的[列表]可以正常地被排序。

#### 大于号

即[运算符>]。

对应的可[重写] [函数]是
`__gt__(self,other)`。

`gt`大概是greater than的缩写。其他的特性与[运算符<]基本一致。

#### 小于等于

即[运算符<=]。

对应的可[重写] [函数]是
`__le__(self,other)`。

`le`大概是less和equal的缩写。

一般来说，若[运算符<=]的左操作数比右操作数小或者相等，则[返回]True，否则[返回]False。这里的`大小`和[运算符<]中的一致。

除了不能作为排序的依据，以及不建议使得[运算符>=]和[运算符<=]逻辑完全相反以外，其他的特性与[运算符<]基本一致。与[运算符<=]是一对。

需要注意：[运算符<=]与[运算符<]没有隐式的联系。如果一个[类]只重载[运算符<]，不会导致[运算符<=]也被重载。如果希望能够产生这些方便的隐式的联系，请参考官方文档的functools.total_ordering：<https://docs.python.org/zh-cn/3/library/functools.html#functools.total_ordering>

#### 大于等于

即[运算符>=]。

对应的可[重写] [函数]是
`__ge__(self,other)`。

`ge`大概是greater和equal的缩写。除了不能作为排序的依据，以及不建议使得[运算符>=]和[运算符<=]逻辑完全相反以外，其他的特性与[运算符<]基本一致。与[运算符<=]是一对。

#### 等于等于

即[运算符==]。

对应的可[重写] [函数]是
`__eq__(self,other)`。

`eq`大概是equal的缩写。

一般地，当左操作数和右操作数相等时[返回]True，否则[返回]False。

对于内置类型，这里的`相等`和[运算符<]中的一致。

需要注意的是：如果一个[类] [重写]了这个[函数]，将会隐式地将`__hash__`设置成[`None`][None]，使得该[类]的[实例]成为[不可哈希对象]，除非`__hash__`也被显式地[重写]。

在不[重写]`__eq__`的默认情况下，自定义[类]的[运算符==]将判断两个[对象]是否是同一个[对象]，即判断其所指向的内存中的位置是否相等。

#### 感叹号等于

即[运算符!=]。

对应的可[重写] [函数]是
`__ne__(self,other)`。

`ne`大概是not eqaual的缩写。

在不[重写]这个[函数]的时候，其逻辑与[运算符==]相反。[重写]这个[函数]不会导致`__hash__`被隐式地设置成[`None`][None]。

### 位运算符

位运算，是计算机科学中的一种快速而强大的运算功能。

计算机内部表示[整数]一般都是用二进制表示的，并不会用十进制数码的[字符串]来表示，那样做运算效率太低。既然是二进制数表示的，那么就有许多二进制位了，每一个位只可能是0或者1，而位运算，就是对这些二进制位进行操作。当然，对于不同的`python`[对象]，[位运算符]有不同的含义，以上只是对数来说的。有关[整数]在计算机的内部表示，请参考[计算机中的整数表示]。

1. [运算符<<]
2. [运算符>>]
3. [运算符&]
4. [运算符|]
5. [运算符^]
6. [运算符~]

#### 小于小于

左移运算符。即[运算符<<]。

函数原型|对应运算
-|-
`__lshift__(self, other)`|self << other
`__rlshift__(self, other)`|other << self

对于[整数]，左移运算就是将左操作数的所有二进制位向高位移动右操作数次，低位用0补齐。在一定程度上，一个[整数]左移a位和乘上2的a次方差不多。其他的内置类型都不支持这个运算符。

在`C++`的代码中，经常可以看到`cout << a`之类的[表达式]。其实这就是重载了[运算符<<]，使得[对象]可以向流传递信息。在`python`中没有这样的机制，当然在`python`中你可以自己定义一些[类]并重载这些运算符来模仿这种行为。

#### 大于大于

右移运算符。即[运算符>>]。

函数原型|对应运算
-|-
`__rshift__(self, other)`|self >> other
`__rrshift__(self, other)`|other >> self

对于[整数]，右移运算（算数右移）就是将左操作数的所有二进制位向低位移动右操作数次，高位用符号位补齐，移出最低位的部分将会被忽略。在一定程度上，一个[整数]右移a位和整除2的a次方差不多。其他的内置类型都不支持这个运算符。

#### 运算符and号

位与运算符。即[运算符&]。

对于[整数]，位与运算是指将两个操作数的各个二进制位对应进行and运算（1代表True，0代表False，高位不存在时用符号位补齐），将得到的各个结果放到对应的位上得到结果[整数]。

例如：

```python
0b1100 & 0b1010     # 得到0b1000（十进制的8），即12 & 10将会得到8
```

函数原型|对应运算
-|-
`__and__(self, other)`|self & other
`__rand__(self, other)`|other & self

下面是一些内置类型进行这个运算的含义。

左操作数|右操作数|[返回值]
-|-|-
[整数]|[整数]|两个数位与运算后得到的[整数]
[布尔类型]|[布尔类型]|相当于`左操作数 and 右操作数`
[布尔类型]|[整数]|将True转换成1，False转换成0再进行[整数]的位与运算
[整数]|[布尔类型]|将True转换成1，False转换成0再进行[整数]的位与运算
[集合]|[集合]|两者的交集

#### 竖线

位或运算符。即[运算符|]。

对于[整数]，位与运算是指将两个操作数的各个二进制位对应进行or运算（1代表True，0代表False，高位不存在时用符号位补齐），将得到的各个结果放到对应的位上得到结果[整数]。

例如：

```python
0b1100 | 0b1010     # 得到0b1110（十进制的14），即12 | 10将会得到14
```

函数原型|对应运算
-|-
`__or__(self, other)`|self | other
`__ror__(self, other)`|other | self

下面是一些内置类型进行这个运算的含义。

左操作数|右操作数|[返回值]
-|-|-
[整数]|[整数]|两个数位或运算后得到的[整数]
[布尔类型]|[布尔类型]|相当于`左操作数 or 右操作数`
[布尔类型]|[整数]|将True转换成1，False转换成0再进行[整数]的位或运算
[整数]|[布尔类型]|将True转换成1，False转换成0再进行[整数]的位或运算
[集合]|[集合]|两者的并集

[整数]的位与、位或运算的一个作用：位或为一个[整数]的某个二进制位置位，位与判断一个[整数]的某个二进制位是否被置位。这在用于控制复杂的模式的时候会很好用，例如re[模块]中正则表达式的匹配模式，就可以通过传入不同的标志（Flags）来完成匹配模式的传递。如果我们用一个[整数]来表示所有的模式，我们就可以用位或运算来将模式叠加，用位与来判断是否添加了这个模式。

#### 尖角

位异或运算符。即[运算符^]。

[布尔类型]中异或（xor）的逻辑：当两者同为True或同为False时，[返回]False，当两者不同时，[返回]True。

真值表如下：

a|b|a xor b
-|-|-
[`True`][True]|[`True`][True]|[`False`][False]
[`True`][True]|[`False`][False]|[`True`][True]
[`False`][False]|[`True`][True]|[`True`][True]
[`False`][False]|[`False`][False]|[`False`][False]

注意：`python`中xor不像[`and`][and]、[`or`][or]那样，它不是一个关键字！

对于[整数]，位异或运算是指将两个操作数的各个二进制位对应进行xor运算（1代表True，0代表False，高位不存在用符号位补齐），将得到的各个结果放到对应的位上得到结果[整数]。

例如：

```python
0b1100 ^ 0b1010     # 得到0b0110（十进制的6），即12 ^ 10将会得到6
```

函数原型|对应运算
-|-
`__xor__(self, other)`|self ^ other
`__rxor__(self, other)`|other ^ self

下面是一些内置类型进行这个运算的含义。

左操作数|右操作数|[返回值]
-|-|-
[整数]|[整数]|两个数位与运算后得到的[整数]
[布尔类型]|[布尔类型]|相当于`左操作数 and 右操作数`
[布尔类型]|[整数]|将True转换成1，False转换成0再进行[整数]的位异或运算
[整数]|[布尔类型]|将True转换成1，False转换成0再进行[整数]的位异或运算
[集合]|[集合]|两者的对称差集，相当于`(a | b) - (a & b)`（两个[集合]分别是a和b）

实际上，对于[整数]，`a ^ b`也总是和`(a | b) - (a & b)`等价。

#### 波浪线

按位取反运算符。即[运算符~]。单目运算符。

对应的可[重写] [函数]是：
`__invert__(self)`

操作数|[返回值]
-|-
[整数]|[整数]按位取反的结果
[布尔类型]|`~True`得到-2，`~False`得到-1，和`~1`，`~0`一致

### 赋值运算符

[赋值运算符]通常用于改变[变量]的[引用]。

由于`python`[变量]创建机制的问题，[赋值运算符]在`Python`中的机制和其他语言不太一样，他们没有[返回值]。但是，在重载他们的时候，我们应当在[重写]的[函数体]中[返回]一个[对象]的[引用]。

1. [运算符=]
2. [运算符+=及其他]

#### 等号

即[运算符=]。

最基础的[赋值运算符]，将一个[对象]的[引用]与一个[变量名]绑定，不可重载。可以用在任何合法的代码空间中，可以在默认参数初始化的地方使用，也可以在需要[键值传递]的地方使用。

此外，关于[运算符=]有一个[语法糖]，即可以为同一个对象一次性绑定多个[变量名]：

```python
a=b=c=d="hello"
```

这样做，将会使得`a`、`b`、`c`、`d`四个[变量]同时指向[字符串]"hello"。

但是这在`C/C++`、`Java`这类语言里面是这样的（假设已经将四个[变量]声明）：\
结合顺序从右到左，先执行d="hello"，[返回]"hello"。
然后执行c='hello'，[返回]"hello"。
然后执行b='hello'，[返回]"hello"。
然后执行a='hello'，[返回]"hello"。
最后一个[返回值]没有被利用，但这无关紧要。

#### 加等于及其他

在此以运算符+=为例，其余的[赋值运算符]都与之类似。

运算符+=意为“加后[赋值]”，将右操作数与左操作数相加后的结果[赋值]给左操作数。左操作数必须能够作为[左值]。

以下的两段代码的逻辑**差不多**。

```python
a=2019
a+=1

a=2019
a=a+1
```

但是其实比这要复杂，下面会展开介绍。

在展开介绍之前，我要说些题外话：\
在`C/C++`、`Java`等语言中，int类型的[整数]可能由一个简单而高效的寄存器来存储，或者在内存中就只有固定大小的字节数供存储，一般来说只有4个字节。而`Python`的int没有长度限制，只要内存还能放，就能加长。

在`C/C++`、`Java`等语言中，int类型的运算符+=就是直接把右操作数加到左操作数上，改变左操作数的值，[返回]改变后的值。这和一般的运算符接收一些操作数，[返回]一个操作数有些不一样，它改变了操作数，而之前我们讲到的运算符（除了[运算符=]）基本上都不会改变操作数。而`python`里的[整数]是[不可变对象]，不可以被改变，可能就是因为[整数]长度无限制，如果可以随意改变，一会儿很长，一会儿很短，那么内存空间的释放回收将会变得很麻烦。因此，要实现经过+=运算以后，改变[变量]所[引用]的[对象]的值是不可能的，办法是：改变[变量]的[引用]。

运算符+=对应的可[重写] [函数]是
`__iadd__(self, other)`

其中i的含义大概是immediately（立即）。

`x+=y`会先尝试调用`x=x.__iadd__(y)`。如果`__iadd__`没有被实现或者[返回]了NotImplemented，那么将会尝试执行x=x+y。**因此，运算符x+=y的含义并不与x=x+y完全相同。**

其余的[赋值运算符]机制与此类似，此处只是列出其对应的可[重写] [函数]，不再重复。

函数原型|运算符
-|-
`__isub__(self, other)`|`-=`
`__imul__(self, other)`|`*=`
`__imatmul__(self, other)`|`@=`
`__itruediv__(self, other)`|`/=`
`__ifloordiv__(self, other)`|`//=`
`__imod__(self, other)`|`%=`
`__ipow__(self, other[, modulo])`|`**=`
`__ilshift__(self, other)`|`<<=`
`__irshift__(self, other)`|`>>=`
`__iand__(self, other)`|`&=`
`__ixor__(self, other)`|`^=`
`__ior__(self, other)`|`|=`

### 其他运算符

剩下的运算符还有以下三个：

1. [运算符\[\]]
2. [运算符\(\)]
3. [运算符,]
4. [运算符\.]
5. [运算符in]
6. [运算符is]

#### 方括号

即[运算符\[\]]。

在这里我们暂时不讨论[切片]。有关[切片]，详见[语法糖]部分。

[运算符\[\]]主要用于进行[索引]访问，[返回] [索引]对应[对象]（可[返回]可作为[左值]的[引用]）。并且，使用的方法和之前提到的运算符也不同，形式如`a[b]`。

对于[字符串]、[列表]、[元组]这些具有[序列]的，单个元素的[索引]是其在[序列]中的编号。它们应当是[整数]。在计算机的世界，计数通常是从0开始数的。

对于[字典]，[索引]是[字典]的[键]。

可[重写] [函数]有两个，对应的功能也不同，一个用于[赋值]（所谓的“[返回] [引用]”），一个用于获取内容。

函数原型|对应运算
-|-
`__getitem__(self, index)`|self[index]（只能做[右值]）
`__setitem__(self, index, value)`|self[index]=value

[重写]了`__getitem__`并且没有将`__iter__`设置成[`None`][None]的[类]的[实例]，将成为[可迭代对象]。

#### 圆括号

[运算符\(\)]有很多地方可以用到。

一个作用是结合，使得被包括的部分成为整体，并调整运算顺序及结构。这和数学意义上的括号很像。这个作用不可以重载。

另一个作用就是[函数调用]。

对应的可[重写] [函数]：

函数原型|对应运算
-|-
`__call__(self[, args...])`|self([args...])

[参数列表]只需要保证至少有第一个self即可，后面的可以根据需要添加。一个[类]只要[重写]了`__call__`[方法]，其[实例]就可以被调用，即与运算符()作用。

#### 逗号

[运算符,]用于构成[元组]、[参数传递]中的分隔的作用。在大多数[序列]中，多一个结尾的逗号是没有关系的，例如`[1,2,3,]`是合法的[列表]。当构成[元组]不会引起歧义时，也可以不用括号，例如这样的[赋值]语句也是可以的：

```python
t=1,'b',[3]
```

在`C/C++`中，逗号`,`是一个不折不扣的运算符，它按照从左到右的顺序执行[表达式]的计算，并[返回]最后一个[表达式]的值。只不过，其优先级非常低，并且也很少有特殊的用途。

#### 点号

[运算符\.]即成员访问运算符。其作用主要是成员（包括[成员变量]和成员[函数]）以及[命名空间]访问。

关于`Python`的成员访问的机制，说起来有些复杂。`python`的很多复杂的机制都是方便程序员的，这对没有任何基础的外行十分不友好。在这里我只介绍最简单的[对象]属性访问机制，其余如果有兴趣可以自行查阅官方文档了解：<https://docs.python.org/zh-cn/3/reference/datamodel.html#customizing-module-attribute-access>。

[运算符\.]的语法约束是`对象.属性名称`。[对象]可以是任何对象，但是当[对象]是[整数常量]时需要加一个空格，例如`13 .__hash__()`。属性名称可以是任意合法的[变量名]。

与之有关联的可[重写] [函数]如下：

函数原型|对应运算|注释
-|-|-
`__getattribute__(self, name:str)`|`self.name`|
`__getattr__(self, name:str)`|`self.name`|仅当属性访问以AttributeError[异常]失败时
`__setattr__(self, name:str, value)`|`self.name=value`|仅当为属性[赋值]时
`__delattr__(self, name:str)`|`del self.name`|仅当销毁[对象]属性时调用

这里的self.name的name将会作为[字符串]传给参数[列表]里的name。

在默认情况（不[重写]以上任何一个[函数]的自定义类型）下，一个[类]AClass的[实例]obj的[运算符\.]大致如下：

1. 在[对象]obj创建时会为其创建一个属性[字典]`__dict__`，这个[字典]总是可以直接用`obj.__dict__`访问，并且这个[字典]不可被[赋值]成[字典]以外的[类型]的[对象]。如果尝试使用del关键字进行删除，那么只是会清空[字典]内容。这个[字典]可以修改内容，和普通的[字典]基本一样。
2. 当在[类]内部[代码块]访问成员时，会为带有前置双下划线并且不属于特殊属性（以双下划线开头和结尾，例如前文提到过的`__add__`等）的属性名称加上前缀`_类名`，即`_AClass`，再进行后一步的操作，例如调用`obj.__hide=1`，将会转换成`obj._AClass__hide=1`来做，而在[类]外部的[代码块]访问成员时，不会这样处理。这实际上就悄悄地屏蔽了外部对加前置双下划线的属性的直接访问，虽然外部还是可以通过`__dict__`或者`_类名`+原属姓名（在本例中即`_AClass__hide`）来访问这些属性。这是一种常用的私有成员机制。
3. 接下来将用属性名称[字符串]作为[键]访问[字典]`__dict__`，来进行获取值或[赋值]值。如果成员访问[表达式]作为[左值]，就相当于直接对[字典]进行操作。例如`obj.a1="hello"`相当于`obj.__dict__["a1"]="hello"`。如果作为[右值]，并且存在对应的[键]，也会正常[返回]。
4. 如果这个属性名称[字符串]不存在于[对象]的`__dict__`的[键]中，并且这个成员访问[表达式]作为[右值]使用，那么将会尝试往[类]的`__dict__`查找。例如`a=obj.x`，其中`x`是`obj.__dict__`中不存在的属性。如果[类]的`__dict__`中也不存在这个[键]，那么将会引发[异常]。

#### 运算符in

在`Python`中，in是一个关键字。

[运算符in]是双目运算符。

对于内置的类型，当左操作数存在于右操作数容器中时，[返回]True，否则[返回]False。

可[重写] [函数]：
`__contains__(self, other)`。

左操作数|右操作数|[返回值]
-|-|-
任意[对象]|[列表]/[元组]/[集合]|左操作数在右边的容器中[返回]True，否则[返回] [`False`][False]
任意[对象]|[字典]|左操作数在[字典]的[键]中[返回]True，否则[返回] [`False`][False]
[字符串]|[字符串]|左字符串是右字符串子串[返回]True，否则[返回] [`False`][False]

#### 运算符is

在`python`中，is是一个关键字，可用于判断两个[对象]是否是同一个[对象]。

当且仅当左操作数和右操作数是同一个[对象]（内存中的地址相同）[返回]True，否则[返回]False。不可重载。

## 关键字

关键字一览
常用关键字的语句

### 关键字一览

你也可以通过[模块]keyword来查看它们。

1. [`False`][False]
2. [`None`][None]
3. [`True`][True]
4. [`and`][and]
5. [`as`][as]
6. [`assert`][assert]
7. [`async`][async]
8. [`await`][await]
9. [`break`][break]
10. [`class`][class]
11. [`continue`][continue]
12. [`def`][def]
13. [`del`][del]
14. [`elif`][elif]
15. [`else`][else]
16. [`except`][except]
17. [`finally`][finally]
18. [`for`][for]
19. [`from`][from]
20. [`global`][global]
21. [`if`][if]
22. [`import`][import]
23. [`in`][in]
24. [`is`][is]
25. [`lambda`][lambda]
26. [`nonlocal`][nonlocal]
27. [`not`][not]
28. [`or`][or]
29. [`pass`][pass]
30. [`raise`][raise]
31. [`return`][return]
32. [`try`][try]
33. [`while`][while]
34. [`with`][with]
35. [`yield`][yield]

#### False

False的含义是[布尔类型]的常量值假。它可以作为[对象]使用。

#### None

[`None`][None]的含义是NoneType类型的常量值。

#### True

False的含义是[布尔类型]的常量值真。它可以作为[对象]使用。

#### and

参考[运算符and]。

#### as

用于特定语句中[对象]的[变量命名]。

#### assert

用于断言。

用法：[assert] [表达式]

如果[表达式]的布尔值为False，并且模式是debug模式，将会引发[异常]。

利用断言[参数]的[类型]来做类型检查是一种比较简单的用法。例如：

```python

def f(n):
    assert isinstance(n,int)
    return "我是复读姬"*n

f(3)            # 正常
f('a')          # 引发AssertionError异常

```

#### async

暂无

#### await

暂无

#### break

用于打断（跳出）当前一层的[for语句]或者[while语句]。

#### class

用于构建自定义类。

用法：

```python
class 类名1(父类1, 父类2, ...):
    代码块1
```

代码块1将被执行，其中使用[`def`][def]定义的[函数]将被绑定到类的[命名空间]中。

#### continue

用于跳过本次循环的剩余[代码块]，到下一次循环。

#### def

用于自定义[函数]。

#### del

用于删除[变量名]或者属性名。若名称不存在将会引发[异常]。

用法：del [左值] [表达式]

#### elif

```python
else:
    if
```

的简化，但是与其有微妙的不同（两者不可以完全替换，会产生一些语法问题）。

可以借此关键字实现switch语句的简单转换。

#### else

详见[if语句]。

#### except

详见[try/except/else/finally]。

#### finally

详见[try/except/else/finally]。

#### for

详见[for语句]。

for也可以用于[推导式]。

#### from

一般用于[import语句]。在协程中也有使用。

#### global

用于声明新的[全局变量]或声明使用全局[变量名]。

语法：[`global`][global] 变量名

执行后，在该局部，此[变量名]将会和[全局变量]等价。

#### if

详见[if语句]。

if还可以用于三元表达式和[推导式]。

三元表达式：

```python
表达式1 if 条件表达式 else 表达式2
```

此[表达式]当`条件表达式`的布尔值为True时将计算并[返回]`表达式1`，否则将计算并[返回]`表达式2`。与C语言里面的三元运算符`a ? b : c`有点相似。

需要注意的是，`表达式1`和`表达式2`的值只有一个会被计算，就像if语句中if后和else后的两个语句块只有一个会被被执行那样。三元表达式本意是为了简化功能简单的[if语句]，同时其本身也是一个[表达式]。

#### import

详见[模块]。

#### in

详见[运算符in]。

#### is

详见[运算符is]。

#### lambda

用于构成lambda表达式。

#### nonlocal

暂无

#### not

详见[运算符not]。

#### or

详见[运算符or]。

#### pass

用于填补语句块结构的空缺。它什么也不做。一般单独成行。

#### raise

用于引发[异常]。

用法：[raise] [异常]（[对象]）

[异常]必须是BaseException的[子类]或其[实例]。

#### return

详见[返回]语句。

#### try

详见[try/except/else/finally]。

#### while

详见[while语句]。

#### with

详见[with语句]。

#### yield

详见[生成器]。

### 常用关键字的语句

1. [if语句]
2. [while语句]
3. [try/except/else/finally]
4. [for语句]
5. [with语句]
6. [import语句]

#### if语句

[if语句]的结构如下：

```python
if 表达式1:
    代码块1
elif 表达式2:
    代码块2
elif 表达式3:
    代码块3
# 可以有任意个elif结构
else:
    代码块n
# 可以有0~1个else结构

```

运行时，将先计算表达式1的布尔值。若表达式1的布尔值为True，代码块1将被执行。代码块1执行后，整个if结构执行完毕。（无论后面有多少elif和else）

如果表达式1的布尔值为False，代码块1将被跳过，并计算表达式2的布尔值。若表达式2的布尔值为True，代码块2将被执行。代码块2执行后，整个if结构执行完毕。（无论后面有多少elif和else）

若表达式2的布尔值也为False，则以此类推向后推进，一直到最后一个elif的[表达式]。若该[表达式]的值的布尔值也为False，则代码块n将被执行。

简单地说，[if语句]必须以if开头，中间夹杂着若干个可有可无的elif，else也可有可无，但只能有一个并且放最后。每个if、elif、else都需要跟上一个[代码块]。[if语句]只会执行结构中第一个[表达式]布尔值为True对应的[代码块]，若全为False则执行else的[代码块]（如果有的话）。

[if语句]主要用于控制条件跳转，使得一些代码只在特定的情况下被执行。

[代码块]的所有行比其对应的if、elif、else多一个[缩进]。

[代码块]的第一行可以写在冒号的后面，但是本人不建议这样做。

#### while语句

[while语句]的结构如下：

```python
while 表达式1:
    代码块1
else:
    代码块2
# 可以有0~1个else结构
```

[while语句]用于循环。

首先计算表达式1的布尔值，如果为True，则执行代码块1。在代码块1中如果遇到了没有被其他循环套住的[continue]，则会跳过代码块1中的剩余代码。使得代码块1运行完毕。如果碰到了没有被其他循环套住的[break]，则会跳出整个[while语句]。

当代码块1执行完毕，将重新计算表达式1的布尔值。如果为True，则会执行代码块1，与上面介绍的一样，如此循环往复。

如果在计算表达式1的布尔值时得到了False，则else部分的代码块2将被执行。当代码块2执行完毕后，[while语句]结束。

[while语句]是循环的基础。主要的有三点：

1. 当循环条件为True时代码块1将被不断循环执行。
2. 循环成立的条件（表达式1的布尔值）的检查仅发生在最开始以及每一次代码块1执行完后。
3. else结构部分的[代码块]仅当这个[while语句]没有被[break]打断时被执行。

以下两个例子将会帮助你理解[while语句]。

```python
n=0
while n<5:
    print(n)
    n+=1
else:
    print(n*10)

# 结果：
# 0
# 1
# 2
# 3
# 4
# 50

n=0
while n<10:
    n+=1
    if n%2==0:
        continue
    if n==7:
        break
    print(n)

# 结果：
# 1
# 3
# 5

```

#### try/except/else/finally

用法：

```python
try:
    代码块0
# except结构可以有任意多个，捕获的类型是可选的。as结构为捕获的异常对象命名，使用时必须有前面的类型，是可选的。
except 类型1 as 变量名1:
    代码块1
except 类型2:
    代码块2
except:
    代码块3
# else结构仅当存在except结构时才可以存在，可以有0~1个
else:
    代码块n1
# finally结构可以有0~1个
finally:
    代码块n2
```

执行try语句从下面的1开始。

1. try结构。一定有代码块0，执行代码块0。
    * 如果代码块0中引发了[异常]，则跳转到2。
    * 如果代码块0没有任何[异常]被引发，则将跳转到3。

2. except结构。
    * 如果有except结构，则将会尝试将[异常]的[类型]与类型1（如果有）进行匹配（如果[异常] [对象]是类型1的[实例]，或类本身，或[子类]，则匹配成功）。不指定捕获的[类型]的except结构，将匹配任何[类型]的[异常]，且必须是最后一个except结构。
        * 如果匹配成功，则将[异常] [对象] [赋值]给变量名1（如果有），这个[变量名]会在代码块1执行完后被删除。接着执行代码块1。
            * 如果代码块1内引发了新的[异常]，那么该[异常] [对象]将会被暂时保存（暂存），并跳到4。
            * 如果代码块1正常结束，那么跳转到4。
        * 如果类型1与[异常] [对象]不匹配，则会进行下一个except结构的匹配，直到找到第一个匹配的。找到后执行其[代码块]，并执行。其逻辑与上述一样。
            * 如果找不到任何匹配的except结构，该[异常]将被暂存，并跳转到4。
    * 如果没有except结构，则跳转到4。
3. else结构。
    * 如果有else结构，则执行代码块n1。
        * 如果有[异常]被引发，则将[异常]暂存，并跳转到4。
        * 如果没有[异常]被引发，则跳转到4。
    * 如果没有else结构，则跳转到4。

4. finally结构。
    * 如果没有finally结构，跳到5。
    * 如果有finally结构，则执行代码块n2。
        * 如果有[异常]被引发，则将新的[异常]替换原来可能的暂存的[异常]，并跳转到5。

5. 重新引发[异常]。
    * 如果有暂存的[异常]或未捕获的[异常]，则将其重新作为从本语句中引发的[异常]引发。

在[try/except/else/finally]中使用[return]、[break]、[continue]是不建议的。这样很容易导致结构混乱。如果你想了解有关在[try/except/else/finally]中使用[return]、[break]、[continue]的详细机制，请参考官方文档：<https://docs.python.org/zh-cn/3/reference/compound_stmts.html#the-try-statement>

#### for语句

[for语句]用于[迭代]和遍历。

所谓遍历，就是将一个容器内的[对象]一个一个全部取出来，分别对它们进行一些操作。

[for语句]的结构如下：

```python
for 变量名 in 可迭代对象:
    代码块1
else:
    代码块2
# 可以有0~1个else结构
```

当[可迭代对象]实现了`__iter__`[方法] [返回]一个[迭代器]，则for循环的逻辑大致和以下的语句一致：

```python
临时迭代器=iter(可迭代对象)
临时状态=True

while 临时状态:
    try:
        变量名=next(临时迭代器)
    except StopIteration:
        临时状态=False
    else:
        代码块1
# 如果没有else和代码块2，此部分将被省略。
else:
    代码块2
```

当[可迭代对象]没有实现`__iter__`[方法]而是实现了`__getitem__`[方法]，并且`__iter__`没有被[赋值]成[`None`][None]，则for循环的逻辑大致和以下的语句一致：

```python
临时索引=0
状态=True

while 状态:
    try:
        变量名=可迭代对象[临时索引]
    except IndexError:
        状态=False
    else:
        代码块1
        临时索引+=1
# 如果没有else和代码块2，此部分将被省略。
else:
    代码块2
```

对于[列表] [实例]作为[可迭代对象]，两个逻辑是一样的。你可以通过以下[例子](/samplecode/forloop.py)来加深对for循环的理解。

```python
ls=[1,'abc',{'hello', 'world'}]

# part1
print("part1:")
for item in ls:
    print(item)

# part2
print("part2:")

临时迭代器=iter(ls)
状态=True

while 状态:
    try:
        item=next(临时迭代器)
    except StopIteration:
        状态=False
    else:
        print(item)

# part3
print("part3:")

临时索引=0
状态=True

while 状态:
    try:
        item=ls[临时索引]
    except IndexError:
        状态=False
    else:
        print(item)
        临时索引+=1

```

#### with语句

[with语句]的语法如下：

```python
# as结构为表达式命名，可选。
with 表达式 as 变量名或变量名列表:
    语句块
```

其逻辑大致等价于：

```python
import sys

临时上下文管理器对象=表达式
临时异常类型,临时异常对象,临时回溯对象=None,None,None
变量名或变量名列表=临时上下文管理器对象.__enter__()
try:
    语句块
except:
    临时异常类型,临时异常对象,临时回溯对象=sys.exc_info()
finally:
    if (临时异常类型,临时异常对象,临时回溯对象) != (None, None, None)
    and not 临时上下文管理器对象.__exit__(临时异常类型,临时异常对象,临时回溯对象):
        raise 临时异常对象
```

如果没有实现上下文管理所需要的两个特殊[函数]`__enter__`和`__exit__`，则会引起问题。如果在try语句块之前就引发了[异常]，那么[异常]将会直接视作由[with语句]引发。从finally结构中的逻辑，我们可以知道如果希望上下文管理器[对象]屏蔽[异常]，应当使得它调用`__exit__`时[返回]一个布尔值为真的[对象]。不过请注意，不要让`__exit__`引发传入的[异常]，这是我们[重写]它时需要确保的。

## 库

1. [模块]
2. [标准库]
3. [第三方库]

### 模块

[模块]是一套具有相关的功能的代码集或程序集，它们往往负责一些功能。在python的代码中，[模块]也是[对象]。

1. [包]
2. [导入模块]
3. [使用模块]

#### 包

英文：Package

[包]是特殊的模块。[包]是一些[模块]的容器，当然这些被容纳的[模块]也可以是[包]。尽管[模块]和一个`python`代码文件很像，[包]和文件夹很像，但是他们是不同的概念，这是因为[模块]不一定要来自于文件系统。在本文的介绍中，我们着重于来自代码文件的自定义[模块]。

直接来自于代码文件的[模块]可以是一个文件夹（[包]），也可以是一个`python`代码文件（普通[模块]），其文件夹名和文件名应当符合[变量名]的命名标准。一般地，我们不去用双下划线开头命名这些文件夹和代码文件，因为这些名称具有一定的特殊性。

一个文件夹如果包含了名为`__init__.py`的代码文件，则此`__init__.py`文件将被视作这个[包]的模块代码，否则这个文件夹将只能作为一个[命名空间] [包]使用，没有模块代码。

[包]可以是不连续的，一个[包]可以由多个位于不同的位置的[包]拼接成，这和`C++`中的namespace以及`Java`中的[包]是相似的。

#### 导入模块

1. [模块名]
2. [import语句]
3. [通过内置函数导入]

##### 模块名

一个[模块]的直接名称就像[变量名]一样。如果这个[模块]来自于文件系统，那么它的名称和这个文件夹或文件的名字（不含扩展名）一样。例如示例代码中的文件夹package1对应[模块]的直接名称是package1，module1.py对应[模块]的直接名称是module1。

一个[模块]的完整名称是从根部的[包]开始，用以点号`.`分隔的[包]的直接名称，这表示其由外向内所属的一层一层的[包]，最后再加上该[模块]的直接名称。这一点和`Java`的完整类名基本上是一致的，只不过`Java`的根部的[包]不会改变，而`Python`的则会随着脚本的位置改变。

当需要在某个脚本中导入一个来自于自己编写的代码文件的[模块]时，这个脚本所在的目录就是根部的[包]。

例如在示例代码中，若以samplecode文件夹为根目录：

* ./package1文件夹被视作一个[包]。
* ./package1/package2文件夹也被视作一个[包]，且在package1文件夹中，是[包]package1中的子[包]。
* `python`代码文件./package1/package2/module2.py在package2文件夹内，是一个普通的[模块]，属于[包]package2。

因此，在脚本./importexample1.py中，[包]package1的完整名称是`package1`，[包]package2的完整名称是`package1.package2`，[模块]module2的完整名称是`package1.package2.module2`。

##### import语句

`python`的[import语句]主要有三种形式：

[import] 完整模块名 [as] 变量名\
[from] 完整模块名 [import] 对象 [as] 变量名\
[from] 完整模块名 [import] *

三个语句一样的部分是：首先要将完整的[模块名]对应的[模块]加载。

对于套在多层[包]中的[模块]，这些[模块]将被按顺序依次加载（详见[importexample1](./samplecode/importexample1.py)），如果其中的某些[模块]已经被加载，则会跳过它们。例如在示例代码中要加载[模块]`package1.package2.module1`，则会依次尝试加载[包]`package1`、[包]`package1.package2`和普通模块`package1.package2.module1`。每一次加载都会将加载出的[模块][对象]放入上一层[模块]的[模块] [命名空间]中（详见[importexample2](./samplecode/importexample2.py)）。

加载一个[包]或者普通[模块]将会执行这个[模块]的模块代码，以进行这些[模块]或[包]的初始化，其中，[包]的模块代码是这个[包]文件夹中的`__init__.py`，普通[模块]的模块代码是其自身。在执行这些代码时，如果碰到了[import语句]（即在一个[import语句]执行模块代码时碰到了别的[import语句]），也会重复一样的过程，但是这时的[import语句]将以最外层的[import语句]所在目录作为根目录（详见[importexample3](./samplecode/importexample3.py)中涉及到的[包]和[模块]）。**因此，如果没有管理好作为入口脚本的位置以及调用自定义[模块]中[import语句]导入的自定义[模块]名，这些自定义[模块]之间的导入将可能会令人困惑地失败**（例如将示例代码中的module4.py作为入口脚本将会引发[异常]）。此外，特殊变量`__name__`的值将会是从[import语句]所在脚本的目录来看的完整模块名（详见[importexample1](./samplecode/importexample1.py)），而在作为入口的脚本中，`__name__`的值总是`__main__`。

这里还涉及一个名称解析的问题。在默认情况下，当文件夹名和代码文件名重复时，将认为这个名字指代的是文件夹。上述的例子（[importexample1](./samplecode/importexample1.py)）中加载`package1.package2`时，虽然文件夹`/package1`中含有代码文件`/package1/package2.py`，但是被加载的是`/package1/package2/__init__.py`。此外，脚本所在的目录优先于一些[库]的目录的搜索，这一点要求我们在为[模块]的文件命名时要格外小心。如果不小心加载了和[库]名称一样的自定义[模块]，将可能导致无法通过[import语句]正常导入相关的[库]（详见[importexample4](./samplecode/importexample4.py)）。

接下来根据不同的语句形式，将加载好的[模块] [对象] [赋值]给变量。

* [import] 完整模块名 [as] 变量名：[as] 变量名部分是可选的。
  * 如果没有[as]结构，则将创建[变量名]与**根模块名**一样的变量，指向根[模块] [对象]，并将其存放在对应的[作用域]中。不必担心根[模块]后面的子[模块]无法使用，由于每一级加载都会将子[模块] [对象]放入上一层[模块]的[模块] [命名空间]，因此你仍然能够通过根[模块]的成员访问来访问他们（详见[importexample1](./samplecode/importexample1.py)）。
  * 如果有[as]结构，那么将创建一个指向完整模块名所对应[模块]的[变量名]，这个[变量名]和[as]后的[变量名]一致。这个变量将被放在对应的[作用域]中。
* [from] 完整模块名 [import] 对象 [as] 变量名
  * 这里的[对象]必须是完整模块名对应[模块]的[模块] [命名空间]中有的[变量]，如果有as结构，那么将这个[变量]重命名成as后的名称，然后将其存放在相应的[作用域]中。
* [from] 完整模块名 [import] *
  * 如果完整模块名对应的[模块]的模块代码中没有声明特殊[变量]`__all__`的值，那么将会把该[模块]中所有不带前置下划线的[变量]存入相应的[作用域]。
  * 如果声明了`__all__`[变量]的值，那么它必须是一个由[字符串常量]组成的[列表]，并且执行该[import语句]后会将该[列表]中所有的名称对应的[变量]导入到相应的[作用域]。（详见[importexample1](./samplecode/importexample1.py)）

> 如果要使用[库]或者调用自定义[模块]的内容，就应该把[import语句]放在执行任何其他代码之前，这是一种习惯。`python`没有强制要求[import语句]的位置在首部，但是应当养成良好的习惯。

##### 通过内置函数导入

使用内置函数`__import__(name, globals=None, locals=None, fromlist=(), level=0)->module`来导入，[返回值]是一个[模块] [对象]。

因为使用比较复杂，详情请参考官方文档：<https://docs.python.org/zh-cn/3/library/importlib.html#importlib.__import__>

#### 使用模块

[模块]也是[对象]，使用[运算符\.]进行成员访问即可得到[模块]中的[对象]。如果直接从[模块]导入了[对象]，那么可以直接使用[变量]。

示例代码见importexample1对f的调用。

### 标准库

`python`[标准库]的功能就十分强大，详情参考官方文档：<https://docs.python.org/zh-cn/3/library/index.html>

### 第三方库

`python`的一大优势是[第三方库]非常丰富，而且用起来也比较优雅。有关[第三方库]，你需要了解一下pip。pip官网：<https://pypi.org/project/pip/>

## 语法糖

[语法糖]是让代码更加简洁，编写更加快捷的机制。下面介绍一些本人所知的`python`[语法糖]。

1. [逻辑表达式]
2. [切片]
3. [迭代]
4. [装饰器]

### 逻辑表达式

`python`的逻辑运算符中，比较大小的[表达式]有一个很好用的[语法糖]：

你可以这样写：

```python
a,b,c,d=1,2,3,4

if a < b < c < d:
    print('a < b < c < d 成立')
```

实际上是解释器将其解释成了：

```python
if a < b and b < c and c < d:
    print('a < b < c < d 成立')
```

当然，其中的小于号可以是`<`、`>`、`<=`、`>=`中的任何一个，可以重复任意次，甚至还可以是一些很奇怪的[表达式]：

```python
if 1 < 3 > 2:
    print(1<3>2)
```

### 切片

英文：Slice

`python`中的[类]名：slice

[切片]本身似乎是`python`特有的。
[切片]是一种很简单的[对象]，它其实就是由三个任意的[对象]组成的，分别叫做start，end，step。顾名思义，start是始，end是末，step是步长。

内置类slice的构造函数根据[参数]个数决定这些[参数]的含义：

1个：[赋值]给end，其余为[`None`][None]\
2个：[赋值]给start和end，step为[`None`][None]\
3个：[赋值]给start、end和step\

例如[表达式]`slice(1,9)`可以得到一个start=1，end=9，step=[`None`][None]的slice[对象]。

slice的构造函数的[赋值]方式和range[对象]有些像，只不过一个[参数]时range的start是0不是[`None`][None]。

对于[列表]及[字符串]这类具有[序列]的[对象]，一个[切片] [对象]可以作为其[索引]使用，但是此时start、end、step必须都是[整数]、[`None`][None]或者是实现了`__index__(self):->int`的[对象]，并且[返回]的是一个子[序列]的拷贝（即子[列表]和子[字符串]，对这个拷贝的修改不会影响到原来的[序列]）。
[返回]的规则如下：

如果不是[整数]或者[`None`][None]，会先调用该[对象]的`__index__(self):->int`来决定[对象]所代表的[整数]，得到start、end、step。

* 如果step为[`None`][None]
  * start为[`None`][None]时，视作从首部开始（包括首部）。
  * end为[`None`][None]时，视作到尾部结束（包括尾部）。
  * [返回]的是[索引]从start开始，到end结束（不含[索引]为end的那一个）的连续[序列]的拷贝。
  * start和end任何一个超出范围，正数超出则视作到尾部结束，负数超出视作到首部结束。
  * 如果start[索引]的位置在end的**后面**，[返回]空[序列]。

* 如果step为0
  * 引发[异常]
* 如果step为正数
  * 基本规则和step为[`None`][None]一致，但是[返回]的[序列]中相邻两项的[索引]是相隔step个的。例如`[1, 2, 3, 4, 5, 6][slice(0, 6, 2)]`将得到`[1, 3, 5]`。
* 如果step为负数
  * start为[`None`][None]时，视作从尾部开始（包括尾部）。
  * end为[`None`][None]时，视作到首部结束（包括尾部）。
  * [返回]的是[索引]从start开始，到end结束（不含[索引]为end的那一个）的逆向的、[索引]隔着-step个的[序列]的拷贝。
  * start和end任何一个超出范围，正数超出则视作到尾部结束，负数超出视作到首部结束。
  * 如果start[索引]的位置在end的**前面**，[返回]空[序列]。

而`python`[切片]的[语法糖]是[运算符\[\]]内部可以通过冒号`:`来构造[切片]。

例如：

```python
ls=[1, 2, 3, 4, 5, 6]

print(ls[start:end])          # 相当于ls[slice(start, end)]
print(ls[start:end:step])     # 相当于ls[slice(start, end, step)]
```

start，end，step的位置都可以省略，那样将被视作[`None`][None]。

### 迭代

[迭代]的原义是一种重复运算的过程，往往需要利用上一次的运算结果对下一次运算做辅助。在本文中，[迭代]指的是有序生成一组[对象]，且每次只能生成一个[对象]的过程。

1. [可迭代对象]
2. [推导式]
3. [迭代器]
4. [生成器]

#### 可迭代对象

英文：Iterable Object

可以不断进行一定的[迭代]操作，得到一个[对象]的[序列]的对象就是[可迭代对象]。[迭代]操作可以是基于[索引]的，例如[列表]，其[索引]一个一个叠加上去，就可以得到不同位置的元素，产生一个对象的[序列]。

还可以像[for语句]那样，先用内置函数`iter`获取对象的一个[迭代器]，然后不断用内置函数`next`对[迭代器]进行[迭代]操作，得到每次[迭代]得到的对象，以生成[对象]的[序列]。能够这样操作的对象也是[可迭代对象]。

请注意本文中的[可迭代对象]和`collections.abc.Iterable`的[实例]是不完全一样的，确切地说，本文中的[可迭代对象]比这个范围还要大一些。

#### 推导式

推导式可以用于生成[列表]、[生成器]、[字典]、[集合]。

所用的框框分别是：[]、()、{}、{}。

需要注意的是用括号()不能直接得到[元组]。可以通过`tuple(生成器)`来得到[元组]。

框框内部的格式如下：

表达式1 for 变量1 in 可迭代对象1 for 变量2 in 可迭代对象2 ... if 表达式2

`for 变量 in 可迭代对象`至少出现一次，多次出现相当于嵌套的for循环。

例如一个100以内奇数的[列表]可以这样写：

```python
[i for i in range(100) if i%2]
```

例如10以内的数的平方的[列表]可以这样写：

```python
[i*i for i in range(10)]
```

实际上这和for循环的机制差不多，只不过是将每次[迭代]中使得表达式2布尔值为True的[序列]保留，并将对应计算出的表达式1的[对象]保存罢了

而[字典]，则表达式1必须是[键值对]的形式。例如小九九[字典]可以这样写：

```python
{f'{a}*{b}':a * b for a in range(1,10) for b in range(1,10) if a < b}
```

而通过推导式得到的[生成器]则不直接将[迭代]进行完，而是得到一个可以被内置函数`next`不断[迭代] [生成器] [对象]。

#### 迭代器

英文：Iterator

这里[迭代器]的含义和`collections.abc.Iterator`的含义基本一致。一个[对象]如果实现了`__iter__(self)`和`__next__(self)`这两个特殊[方法]，就是一个[迭代器] [对象]。通常，`__iter__(self)`[返回]自身。[迭代器]也是[可迭代对象]。

[迭代器]的好处是：它占用空间比较小。因为[迭代器]每次[迭代] [返回]一个[对象]，其本身不一定存储了这些[数据]，而是通过计算得到。用[迭代器]来“保存”一些只用一次的较长的临时的[序列]是不错的选择，强行用[列表]、[元组]等存储会带来很大的内存空间和垃圾回收开销的浪费。

很多内置函数都[返回]一个[迭代器]，可以很方便地不写循环语句就完成[迭代]操作。

本人已知的有以下：

函数原型|[返回] [迭代器]
-|-
map(func:function, iterable:Iterable)|iterable经function映射后的[对象] [序列]的[迭代器]
filter(func:function, iterable:Iterable)|iterable经function映射后布尔值为True的[序列]的[迭代器]

顾名思义，map就是映射器，filter就是过滤器。一些简单的[迭代]逻辑不必写个for循环去实现它。

#### 生成器

英文：Generator

[生成器]也是一种[迭代器]，但是它的[数据]空间往往更小。一种[生成器]的构成方式是推导式。

另一种方式是在定义[函数]时，在[函数体]内使用[yield]关键字来使得[函数] [返回]一个[生成器]。

一旦一个[函数体]内有[yield]关键字，当调用这个[函数]时，[函数]会[返回]一个[生成器]。这时[函数体]内的代码不会被执行，而是保存[参数]暂用。

假设将[生成器] [赋值]给了一个[变量]ge，那么当调用next(ge)时，将会使得[函数体]开始运作，直到遇到一个[yield]语句。

`yield 表达式`将[表达式]的值作为[迭代]的[返回值]。之后，将会暂停[函数]的执行，回到调用next的地方。

当再次调用next(ge)时，将会使得[函数体]的执行从刚暂停的地方继续开始，重复以上。

当[函数]真正[返回]或者产生[异常]时，[生成器]的[迭代]终止。如果[异常]是StopIteration，则应当认为[迭代]是正常终止（或已经终止）的。

下面简单举一个生成给定[参数]以内的斐波那契数列的[生成器]例子。

```python
def fibo(n):
    a,b=0,1
    while b <= n:
        yield b
        a, b=b, a + b

for i in fibo(100):
    print(i)
```

### 装饰器

英文：Decorator

[装饰器]其实就两件事情：

1. [函数]也是[对象]
2. @的一个[语法糖]：

```python

@decorator1
def function1(...):
    ...

# 差不多等价于

def function1(...):
    ...

# def也可以是class

function1=decorator1(funcnion1)
```

此外，如果有多个被@装饰的情况，结合顺序是由下至上。即：

```python
@a
@b
def function(...):
    ...

# 差不多等价于

def function(...):
    ...
function=a(b(function))

```

[装饰器]的作用是：使得[函数]或者[类]被装饰，可能是为它附加一些操作。下面的例子可以让你更好地理解[装饰器]的执行过程：

```python
def message(func):
    print(f'{func}的装饰器初始化')
    def w(*args, **kw):
        positional=','.join(str(i) for i in args)
        keyword=','.join(f'{k}={v}' for k, v in kw.items())
        argls=f"{positional}{',' if positional != '' else ''}{keyword}"
        print(f'调用函数 {func.__name__}({argls})')
        rs=func(*args, **kw)
        print(f'调用函数 {func.__name__}({argls}) 结束')
        return rs
    return w

class A:
    def __init__(self,data):
        print(f'对象{self}初始化')
        self.data=data
    @message
    def echo(self):
        print(f'复述{self.data}')

a=A('你好')
a.echo()
```

## 名词解释

### 类

英文：Class

[类]是对一些具有相同特征的[对象]的共性的抽象。\
例如“显示屏”是[类]，“你正在看的显示屏”则是一个“显示屏”的[实例]。\
例如“狗”是[类]，“我家楼下的小黄狗”则是一个“狗”的[实例]。

### 数据

英文：Data/Attribute

别名：属性

本文指的是一个[类]所[封装]的[对象]，或者一些单纯地被存储的信息。

### 方法

英文：Method

方法是[对象]的“功能”，即[对象]可以干什么。

### 接口

英文：Interface

本文的[接口]指的是一套功能或者交互的标准。\
[接口]只是声明：实现这个[接口]的[对象]就意味着有哪些[方法]。\
[接口]本身不应该有相应的实现。

### 子类

英文：Subclass

[子类]是两个[类]之间的关系。\
如果[类]A[继承]了[类]B，那么[类]A是[类]B的[子类]。

### 父类

英文：Superclass

[父类]是两个[类]之间的关系。\
如果[类]A[继承]了[类]B，那么[类]B是[类]A的[父类]。

### 实例

英文：Instance

[实例]是一个[类]的具体的[对象]。\
有时候，我们可以将[实例]看成是和[对象]一样的含义（但不建议这样做）。

### 重写

英文：Override

别名：覆写

[子类]重新实现并覆盖[父类]的[方法]，叫做[重写]。

### 表达式

英文：Expression

由[对象]（或[变量]）和运算符组成的具有值的代码段。

### 异常

英文：Exception

[异常]由程序中的一些不正当的操作引起。如果处理不当，将可能使得程序被迫错误地终止。

### 键

英文：Key

本文中的[键]指的是[字典]中被用于映射的一方。映射到的一方叫做值。如果将[字典]比作[函数]，那么[键]就是自变量，值就是函数值。一个[键]只能映射到一个值，而一个值可以被多个[键]映射到。

### 不可变对象

英文：Immutable Object

顾名思义，[不可变对象]就是不可以被改变内容的[对象]，他们一旦被创建完成，就永远是不变的。

### 可变对象

英文：Mutable Object

顾名思义，[可变对象]就是可以改变内容的[对象]。由于可变性的存在，它们一般是[不可哈希对象]。

### 哈希

英文：Hash

[哈希]其实是一类算法，作用是将一些[对象]映射到一个[整数]，这个[整数]的值叫做哈希值。不过这些[整数]可能会重复，即产生哈希冲突。一个良好的哈希算法产生的哈希冲突较少。

### 可哈希对象

英文：Hashable Object

可以被哈希算法映射的[对象]就是[可哈希对象]。

### 不可哈希对象

英文：Unhashable Object

不可以被哈希算法映射的[对象]就是[不可哈希对象]。

### 索引

英文：Index

如果我们把可用[索引]查找的容器[对象]比作书，那么[索引]就像页码一样。有了[索引]，我们可以快速找到容器里的[对象]，就像有了页码，我们能够快速地翻到某个特定的位置。

### 左值

英文：Lvalue

[左值]是可以放在[赋值]语句左边的值或[表达式]。

### 右值

英文：Rvalue

[右值]是可以放在[赋值]语句右边的值或[表达式]。

### 缩进

英文：Indentation

[缩进]是`Python`中表示结构的方法。一个具有[缩进]的结构被视作为上一个[缩进]比它少的结构的子结构。一般而言，一个[缩进]是4个空格。下面的示例可能对理解这个有一定的帮助。

```python
无缩进的行1
    一个缩进的行2
    一个缩进的行3
        两个缩进的行4
        两个缩进的行5
        两个缩进的行6
    一个缩进的行7
无缩进的行8
    一个缩进的行9
无缩进的行10
```

### 代码块

英文：Block

顾名思义，[代码块]就是代码的块。一般而言，在`Python`中具有相同的最小[缩进个数]的连续（忽略空行）的代码行属于同一个[代码块]，这个最小的[缩进]的个数是这个[代码块]的[缩进个数]。一般我们讲[代码块]都是指行尽可能地多的[代码块]。所有行都在一个[代码块]A内，且[缩进个数]更多的[代码块]B是[代码块]A的[子代码块]。

例如上面的示例中，行1-10属于同一个[代码块]，[缩进个数]为0。行2-7属于同一个[代码块]，[缩进个数]是1，且是行1-10的[代码块]的[子代码块]。行4-6属于同一个[代码块]，[缩进个数]为2，且是行2-7的[代码块]的子[代码块]。行9是一个[代码块]，是行1-10的[代码块]的[子代码块]。但是，**行2-7和行9不是同一个[代码块]**，因为不连续。如果你学过`C/C++`或者`Java`，那么它的结构看起来应该是这样（同一对花括号`{}`内是同一个代码块）：

```java
{
    无缩进的行1
    {
        一个缩进的行2
        一个缩进的行3
        {
            两个缩进的行4
            两个缩进的行5
            两个缩进的行6
        }
        一个缩进的行7
    }
    无缩进的行8
    {
        一个缩进的行9
    }
    无缩进的行10
}
```

### 序列

英文：Sequence

[序列]是按照一定顺序排列的某些东西。例如高考分数的排名名单、节目单的出场顺序、星期一的课程表/作息表，都是具体的[序列]。

[Python 基础教程]:#Python-基础教程
[写在前面]:#写在前面
[目录]:#目录
[对象]:#对象
[什么是对象]:#什么是对象
[为什么我需要知道对象的概念]:#为什么我需要知道对象的概念
[Python的对象]:#Python的对象
[面向对象的程序设计]:#面向对象的程序设计
[封装]:#封装
[继承]:#继承
[多态]:#多态
[object]:#object
[函数]:#函数
[什么是函数]:#什么是函数
[参数]:#参数
[函数体]:#函数体
[函数调用]:#函数调用
[返回]:#返回
[返回值]:#返回值
[返回语句]:#返回语句
[Python-函数]:#Python-函数
[Python-自定义函数]:#Python-自定义函数
[Python-参数传递]:#Python-参数传递
[参数列表]:#参数列表
[位置参数]:#位置参数
[含默认值的位置参数]:#含默认值的位置参数
[可变参数]:#可变参数
[仅键值参数]:#仅键值参数
[字典参数]:#字典参数
[参数列表语法]:#参数列表语法
[参数传递]:#参数传递
[位置传递]:#位置传递
[键值传递]:#键值传递
[解包传递]:#解包传递
[迭代解包]:#迭代解包
[键值解包]:#键值解包
[传递机制]:#传递机制
[数据结构]:#数据结构
[类型]:#类型
[布尔类型]:#布尔类型
[数]:#数
[整数]:#整数
[数制]:#数制
[计算机中的整数表示]:#计算机中的整数表示
[整数常量]:#整数常量
[浮点数]:#浮点数
[浮点数常量]:#浮点数常量
[浮点表示]:#浮点表示
[指数表示]:#指数表示
[复数]:#复数
[字符串]:#字符串
[字符]:#字符
[字符串常量]:#字符串常量
[字符串前缀]:#字符串前缀
[转义字符]:#转义字符
[一些常用的字符串操作]:#一些常用的字符串操作
[拼接]:#拼接
[复制]:#复制
[格式化]:#格式化
[索引与切片]:#索引与切片
[查找与替换]:#查找与替换
[子串查找]:#子串查找
[子串替换]:#子串替换
[正则表达式]:#正则表达式
[正则式]:#正则式
[编译对象]:#编译对象
[match对象]:#match对象
[列表]:#列表
[创建列表]:#创建列表
[列表索引]:#列表索引
[元组]:#元组
[集合]:#集合
[创建集合]:#创建集合
[字典]:#字典
[创建字典]:#创建字典
[字典索引]:#字典索引
[变量]:#变量
[变量名]:#变量名
[变量命名]:#变量命名
[赋值]:#赋值
[直接赋值]:#直接赋值
[解包赋值]:#解包赋值
[引用]:#引用
[作用域]:#作用域
[命名空间]:#命名空间
[局部变量]:#局部变量
[全局变量]:#全局变量
[成员变量]:#成员变量
[运算符]:#运算符
[运算符重载]:#运算符重载
[算术运算符]:#算术运算符
[运算符+]:#加号
[运算符-]:#减号
[运算符*]:#星号
[运算符**]:#双星号
[运算符/]:#除号
[运算符//]:#双斜杠
[运算符%]:#百分号
[运算符@]:#艾特
[逻辑运算符]:#逻辑运算符
[运算符not]:#运算符not
[运算符and]:#运算符and
[运算符or]:#运算符or
[逻辑短路]:#逻辑短路
[比较运算符]:#比较运算符
[运算符<]:#小于
[运算符>]:#大于
[运算符<=]:#小于等于
[运算符>=]:#大于等于
[运算符==]:#等于等于
[运算符!=]:#感叹号等于
[位运算符]:#位运算符
[运算符<<]:#小于小于
[运算符>>]:#大于大于
[运算符&]:#and号
[运算符|]:#竖线
[运算符^]:#尖角
[运算符~]:#波浪线
[赋值运算符]:#赋值运算符
[运算符=]:#等号
[运算符+=及其他]:#加等于及其他
[其他运算符]:#其他运算符
[运算符\[\]]:#方括号
[运算符\(\)]:#圆括号
[运算符,]:#逗号
[运算符\.]:#点号
[运算符in]:#运算符in
[运算符is]:#运算符is
[关键字]:#关键字
[关键字一览]:#关键字一览
[False]:#false
[None]:#none
[True]:#true
[and]:#and
[as]:#as
[assert]:#assert
[async]:#async
[await]:#await
[break]:#break
[class]:#class
[continue]:#continue
[def]:#def
[del]:#del
[elif]:#elif
[else]:#else
[except]:#except
[finally]:#finally
[for]:#for
[from]:#from
[global]:#global
[if]:#if
[import]:#import
[in]:#in
[is]:#is
[lambda]:#lambda
[nonlocal]:#nonlocal
[not]:#not
[or]:#or
[pass]:#pass
[raise]:#raise
[return]:#return
[try]:#try
[while]:#while
[with]:#with
[yield]:#yield
[常用关键字的语句]:#常用关键字的语句
[if语句]:#if语句
[while语句]:#while语句
[try/except/else/finally]:#try/except/else/finally
[for语句]:#for语句
[with语句]:#with语句
[库]:#库
[模块]:#模块
[包]:#包
[导入模块]:#导入模块
[模块名]:#模块名
[import语句]:#import语句
[通过内置函数导入]:#通过内置函数导入
[使用模块]:#使用模块
[标准库]:#标准库
[第三方库]:#第三方库
[语法糖]:#语法糖
[逻辑表达式]:#逻辑表达式
[切片]:#切片
[迭代]:#迭代
[可迭代对象]:#可迭代对象
[推导式]:#推导式
[迭代器]:#迭代器
[生成器]:#生成器
[装饰器]:#装饰器
[名词解释]:#名词解释
[类]:#类
[数据]:#数据
[方法]:#方法
[接口]:#接口
[子类]:#子类
[父类]:#父类
[实例]:#实例
[重写]:#重写
[表达式]:#表达式
[异常]:#异常
[键]:#键
[不可变对象]:#不可变对象
[哈希]:#哈希
[可哈希对象]:#可哈希对象
[不可哈希对象]:#不可哈希对象
[索引]:#索引
[左值]:#左值
[右值]:#右值
[缩进]:#缩进
[代码块]:#代码块
[缩进个数]:#代码块
[子代码块]:#代码块
[键值对]:#字典
[序列]:#序列
[可变对象]:#可变对象
